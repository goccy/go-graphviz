// Code generated by protoc-gen-nori. DO NOT EDIT!

package wasm

import (
	"context"
	_ "embed"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strconv"
	"unsafe"

	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
	"github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1"
)

var _ unsafe.Pointer

//go:embed graphviz.wasm
var wasmFile []byte

type WasmModule struct {
	mod             api.Module
	lookupFuncMap   *LookupFuncMap
	callbackFuncMap *CallbackFuncMap
}

type LookupFuncMap struct {
	IDAllocator_Open                     func(*Graph, *ClientDiscipline) (uint64, error)
	IDAllocator_Map                      func(any, int, string, *uint64, int) (uint64, error)
	IDAllocator_Alloc                    func(any, int, uint64) (uint64, error)
	IDAllocator_Free                     func(any, int, uint64) (uint64, error)
	IDAllocator_Print                    func(any, int, uint64) (uint64, error)
	IDAllocator_Close                    func(any) (uint64, error)
	IDAllocator_IdRegister               func(any, int, any) (uint64, error)
	IOService_Afread                     func(any, string, int) (uint64, error)
	IOService_Putstr                     func(any, string) (uint64, error)
	IOService_Flush                      func(any) (uint64, error)
	ClientEventCallback_ObjectFunc       func(*Graph, *Object, any) (uint64, error)
	ClientEventCallback_ObjectUpdateFunc func(*Graph, *Object, any, *Sym) (uint64, error)
	UserRef                              func(string) (uint64, error)
	DictMemory                           func(*Dict, any, uint32, *DictDisc) (uint64, error)
	DictSearch                           func(*Dict, any, int) (uint64, error)
	DictMake                             func(any, *DictDisc) (uint64, error)
	DictFree                             func(any) (uint64, error)
	DictCompare                          func(any, any) (uint64, error)
	DictWalk                             func(any, any) (uint64, error)
	UserShape_DataFree                   func(*UserShape) (uint64, error)
	DeviceCallbacks_Refresh              func(*Job) (uint64, error)
	DeviceCallbacks_ButtonPress          func(*Job, int, *PointFloat) (uint64, error)
	DeviceCallbacks_ButtonRelease        func(*Job, int, *PointFloat) (uint64, error)
	DeviceCallbacks_Motion               func(*Job, *PointFloat) (uint64, error)
	DeviceCallbacks_Modify               func(*Job, string, string) (uint64, error)
	DeviceCallbacks_Delete               func(*Job) (uint64, error)
	DeviceCallbacks_Read                 func(*Job, string, string) (uint64, error)
	DeviceCallbacks_Layout               func(*Job, string) (uint64, error)
	DeviceCallbacks_Render               func(*Job, string, string) (uint64, error)
	DeviceEngine_Initialize              func(*Job) (uint64, error)
	DeviceEngine_Format                  func(*Job) (uint64, error)
	DeviceEngine_Finalize                func(*Job) (uint64, error)
	RenderEngine_BeginJob                func(*Job) (uint64, error)
	RenderEngine_EndJob                  func(*Job) (uint64, error)
	RenderEngine_BeginGraph              func(*Job) (uint64, error)
	RenderEngine_EndGraph                func(*Job) (uint64, error)
	RenderEngine_BeginLayer              func(*Job, string, int, int) (uint64, error)
	RenderEngine_EndLayer                func(*Job) (uint64, error)
	RenderEngine_BeginPage               func(*Job) (uint64, error)
	RenderEngine_EndPage                 func(*Job) (uint64, error)
	RenderEngine_BeginCluster            func(*Job) (uint64, error)
	RenderEngine_EndCluster              func(*Job) (uint64, error)
	RenderEngine_BeginNodes              func(*Job) (uint64, error)
	RenderEngine_EndNodes                func(*Job) (uint64, error)
	RenderEngine_BeginEdges              func(*Job) (uint64, error)
	RenderEngine_EndEdges                func(*Job) (uint64, error)
	RenderEngine_BeginNode               func(*Job) (uint64, error)
	RenderEngine_EndNode                 func(*Job) (uint64, error)
	RenderEngine_BeginEdge               func(*Job) (uint64, error)
	RenderEngine_EndEdge                 func(*Job) (uint64, error)
	RenderEngine_BeginAnchor             func(*Job, string, string, string, string) (uint64, error)
	RenderEngine_EndAnchor               func(*Job) (uint64, error)
	RenderEngine_BeginLabel              func(*Job, LabelType) (uint64, error)
	RenderEngine_EndLabel                func(*Job) (uint64, error)
	RenderEngine_Textspan                func(*Job, *PointFloat, *Textspan) (uint64, error)
	RenderEngine_ResolveColor            func(*Job, *Color) (uint64, error)
	RenderEngine_Ellipse                 func(*Job, []*PointFloat, int) (uint64, error)
	RenderEngine_Polygon                 func(*Job, []*PointFloat, uint32, int) (uint64, error)
	RenderEngine_Beziercurve             func(*Job, []*PointFloat, uint32, int) (uint64, error)
	RenderEngine_Polyline                func(*Job, []*PointFloat, uint32) (uint64, error)
	RenderEngine_Comment                 func(*Job, string) (uint64, error)
	RenderEngine_LibraryShape            func(*Job, string, []*PointFloat, uint32, int) (uint64, error)
	LayoutEngine_Layout                  func(*Graph) (uint64, error)
	LayoutEngine_Cleanup                 func(*Graph) (uint64, error)
	TextLayoutEngine_TextLayout          func(*Textspan, []string) (uint64, error)
	LoadImageEngine_LoadImage            func(*Job, *UserShape, *BoxFloat, bool) (uint64, error)
}

type CallbackFuncMap struct {
	IDAllocator_Open                     map[uint64]func(context.Context, *Graph, *ClientDiscipline) (any, error)
	IDAllocator_Map                      map[uint64]func(context.Context, any, int, string, *uint64, int) (int32, error)
	IDAllocator_Alloc                    map[uint64]func(context.Context, any, int, uint64) (int32, error)
	IDAllocator_Free                     map[uint64]func(context.Context, any, int, uint64) error
	IDAllocator_Print                    map[uint64]func(context.Context, any, int, uint64) (string, error)
	IDAllocator_Close                    map[uint64]func(context.Context, any) error
	IDAllocator_IdRegister               map[uint64]func(context.Context, any, int, any) error
	IOService_Afread                     map[uint64]func(context.Context, any, string, int) (int, error)
	IOService_Putstr                     map[uint64]func(context.Context, any, string) (int, error)
	IOService_Flush                      map[uint64]func(context.Context, any) (int, error)
	ClientEventCallback_ObjectFunc       map[uint64]func(context.Context, *Graph, *Object, any) error
	ClientEventCallback_ObjectUpdateFunc map[uint64]func(context.Context, *Graph, *Object, any, *Sym) error
	UserRef                              map[uint64]func(context.Context, string) (int, error)
	DictMemory                           map[uint64]func(context.Context, *Dict, any, uint32, *DictDisc) (any, error)
	DictSearch                           map[uint64]func(context.Context, *Dict, any, int) (any, error)
	DictMake                             map[uint64]func(context.Context, any, *DictDisc) (any, error)
	DictFree                             map[uint64]func(context.Context, any) error
	DictCompare                          map[uint64]func(context.Context, any, any) (int, error)
	DictWalk                             map[uint64]func(context.Context, any, any) (int, error)
	UserShape_DataFree                   map[uint64]func(context.Context, *UserShape) error
	DeviceCallbacks_Refresh              map[uint64]func(context.Context, *Job) error
	DeviceCallbacks_ButtonPress          map[uint64]func(context.Context, *Job, int, *PointFloat) error
	DeviceCallbacks_ButtonRelease        map[uint64]func(context.Context, *Job, int, *PointFloat) error
	DeviceCallbacks_Motion               map[uint64]func(context.Context, *Job, *PointFloat) error
	DeviceCallbacks_Modify               map[uint64]func(context.Context, *Job, string, string) error
	DeviceCallbacks_Delete               map[uint64]func(context.Context, *Job) error
	DeviceCallbacks_Read                 map[uint64]func(context.Context, *Job, string, string) error
	DeviceCallbacks_Layout               map[uint64]func(context.Context, *Job, string) error
	DeviceCallbacks_Render               map[uint64]func(context.Context, *Job, string, string) error
	DeviceEngine_Initialize              map[uint64]func(context.Context, *Job) error
	DeviceEngine_Format                  map[uint64]func(context.Context, *Job) error
	DeviceEngine_Finalize                map[uint64]func(context.Context, *Job) error
	RenderEngine_BeginJob                map[uint64]func(context.Context, *Job) error
	RenderEngine_EndJob                  map[uint64]func(context.Context, *Job) error
	RenderEngine_BeginGraph              map[uint64]func(context.Context, *Job) error
	RenderEngine_EndGraph                map[uint64]func(context.Context, *Job) error
	RenderEngine_BeginLayer              map[uint64]func(context.Context, *Job, string, int, int) error
	RenderEngine_EndLayer                map[uint64]func(context.Context, *Job) error
	RenderEngine_BeginPage               map[uint64]func(context.Context, *Job) error
	RenderEngine_EndPage                 map[uint64]func(context.Context, *Job) error
	RenderEngine_BeginCluster            map[uint64]func(context.Context, *Job) error
	RenderEngine_EndCluster              map[uint64]func(context.Context, *Job) error
	RenderEngine_BeginNodes              map[uint64]func(context.Context, *Job) error
	RenderEngine_EndNodes                map[uint64]func(context.Context, *Job) error
	RenderEngine_BeginEdges              map[uint64]func(context.Context, *Job) error
	RenderEngine_EndEdges                map[uint64]func(context.Context, *Job) error
	RenderEngine_BeginNode               map[uint64]func(context.Context, *Job) error
	RenderEngine_EndNode                 map[uint64]func(context.Context, *Job) error
	RenderEngine_BeginEdge               map[uint64]func(context.Context, *Job) error
	RenderEngine_EndEdge                 map[uint64]func(context.Context, *Job) error
	RenderEngine_BeginAnchor             map[uint64]func(context.Context, *Job, string, string, string, string) error
	RenderEngine_EndAnchor               map[uint64]func(context.Context, *Job) error
	RenderEngine_BeginLabel              map[uint64]func(context.Context, *Job, LabelType) error
	RenderEngine_EndLabel                map[uint64]func(context.Context, *Job) error
	RenderEngine_Textspan                map[uint64]func(context.Context, *Job, *PointFloat, *Textspan) error
	RenderEngine_ResolveColor            map[uint64]func(context.Context, *Job, *Color) error
	RenderEngine_Ellipse                 map[uint64]func(context.Context, *Job, []*PointFloat, int) error
	RenderEngine_Polygon                 map[uint64]func(context.Context, *Job, []*PointFloat, uint32, int) error
	RenderEngine_Beziercurve             map[uint64]func(context.Context, *Job, []*PointFloat, uint32, int) error
	RenderEngine_Polyline                map[uint64]func(context.Context, *Job, []*PointFloat, uint32) error
	RenderEngine_Comment                 map[uint64]func(context.Context, *Job, string) error
	RenderEngine_LibraryShape            map[uint64]func(context.Context, *Job, string, []*PointFloat, uint32, int) error
	LayoutEngine_Layout                  map[uint64]func(context.Context, *Graph) error
	LayoutEngine_Cleanup                 map[uint64]func(context.Context, *Graph) error
	TextLayoutEngine_TextLayout          map[uint64]func(context.Context, *Textspan, []string) (bool, error)
	LoadImageEngine_LoadImage            map[uint64]func(context.Context, *Job, *UserShape, *BoxFloat, bool) error
}

func Register_IDAllocator_Open(fn func(*Graph, *ClientDiscipline) (uint64, error)) {
	mod.lookupFuncMap.IDAllocator_Open = fn
}
func Register_IDAllocator_Map(fn func(any, int, string, *uint64, int) (uint64, error)) {
	mod.lookupFuncMap.IDAllocator_Map = fn
}
func Register_IDAllocator_Alloc(fn func(any, int, uint64) (uint64, error)) {
	mod.lookupFuncMap.IDAllocator_Alloc = fn
}
func Register_IDAllocator_Free(fn func(any, int, uint64) (uint64, error)) {
	mod.lookupFuncMap.IDAllocator_Free = fn
}
func Register_IDAllocator_Print(fn func(any, int, uint64) (uint64, error)) {
	mod.lookupFuncMap.IDAllocator_Print = fn
}
func Register_IDAllocator_Close(fn func(any) (uint64, error)) {
	mod.lookupFuncMap.IDAllocator_Close = fn
}
func Register_IDAllocator_IdRegister(fn func(any, int, any) (uint64, error)) {
	mod.lookupFuncMap.IDAllocator_IdRegister = fn
}
func Register_IOService_Afread(fn func(any, string, int) (uint64, error)) {
	mod.lookupFuncMap.IOService_Afread = fn
}
func Register_IOService_Putstr(fn func(any, string) (uint64, error)) {
	mod.lookupFuncMap.IOService_Putstr = fn
}
func Register_IOService_Flush(fn func(any) (uint64, error)) {
	mod.lookupFuncMap.IOService_Flush = fn
}
func Register_ClientEventCallback_ObjectFunc(fn func(*Graph, *Object, any) (uint64, error)) {
	mod.lookupFuncMap.ClientEventCallback_ObjectFunc = fn
}
func Register_ClientEventCallback_ObjectUpdateFunc(fn func(*Graph, *Object, any, *Sym) (uint64, error)) {
	mod.lookupFuncMap.ClientEventCallback_ObjectUpdateFunc = fn
}
func Register_UserRef(fn func(string) (uint64, error)) {
	mod.lookupFuncMap.UserRef = fn
}
func Register_DictMemory(fn func(*Dict, any, uint32, *DictDisc) (uint64, error)) {
	mod.lookupFuncMap.DictMemory = fn
}
func Register_DictSearch(fn func(*Dict, any, int) (uint64, error)) {
	mod.lookupFuncMap.DictSearch = fn
}
func Register_DictMake(fn func(any, *DictDisc) (uint64, error)) {
	mod.lookupFuncMap.DictMake = fn
}
func Register_DictFree(fn func(any) (uint64, error)) {
	mod.lookupFuncMap.DictFree = fn
}
func Register_DictCompare(fn func(any, any) (uint64, error)) {
	mod.lookupFuncMap.DictCompare = fn
}
func Register_DictWalk(fn func(any, any) (uint64, error)) {
	mod.lookupFuncMap.DictWalk = fn
}
func Register_UserShape_DataFree(fn func(*UserShape) (uint64, error)) {
	mod.lookupFuncMap.UserShape_DataFree = fn
}
func Register_DeviceCallbacks_Refresh(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.DeviceCallbacks_Refresh = fn
}
func Register_DeviceCallbacks_ButtonPress(fn func(*Job, int, *PointFloat) (uint64, error)) {
	mod.lookupFuncMap.DeviceCallbacks_ButtonPress = fn
}
func Register_DeviceCallbacks_ButtonRelease(fn func(*Job, int, *PointFloat) (uint64, error)) {
	mod.lookupFuncMap.DeviceCallbacks_ButtonRelease = fn
}
func Register_DeviceCallbacks_Motion(fn func(*Job, *PointFloat) (uint64, error)) {
	mod.lookupFuncMap.DeviceCallbacks_Motion = fn
}
func Register_DeviceCallbacks_Modify(fn func(*Job, string, string) (uint64, error)) {
	mod.lookupFuncMap.DeviceCallbacks_Modify = fn
}
func Register_DeviceCallbacks_Delete(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.DeviceCallbacks_Delete = fn
}
func Register_DeviceCallbacks_Read(fn func(*Job, string, string) (uint64, error)) {
	mod.lookupFuncMap.DeviceCallbacks_Read = fn
}
func Register_DeviceCallbacks_Layout(fn func(*Job, string) (uint64, error)) {
	mod.lookupFuncMap.DeviceCallbacks_Layout = fn
}
func Register_DeviceCallbacks_Render(fn func(*Job, string, string) (uint64, error)) {
	mod.lookupFuncMap.DeviceCallbacks_Render = fn
}
func Register_DeviceEngine_Initialize(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.DeviceEngine_Initialize = fn
}
func Register_DeviceEngine_Format(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.DeviceEngine_Format = fn
}
func Register_DeviceEngine_Finalize(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.DeviceEngine_Finalize = fn
}
func Register_RenderEngine_BeginJob(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_BeginJob = fn
}
func Register_RenderEngine_EndJob(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_EndJob = fn
}
func Register_RenderEngine_BeginGraph(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_BeginGraph = fn
}
func Register_RenderEngine_EndGraph(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_EndGraph = fn
}
func Register_RenderEngine_BeginLayer(fn func(*Job, string, int, int) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_BeginLayer = fn
}
func Register_RenderEngine_EndLayer(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_EndLayer = fn
}
func Register_RenderEngine_BeginPage(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_BeginPage = fn
}
func Register_RenderEngine_EndPage(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_EndPage = fn
}
func Register_RenderEngine_BeginCluster(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_BeginCluster = fn
}
func Register_RenderEngine_EndCluster(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_EndCluster = fn
}
func Register_RenderEngine_BeginNodes(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_BeginNodes = fn
}
func Register_RenderEngine_EndNodes(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_EndNodes = fn
}
func Register_RenderEngine_BeginEdges(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_BeginEdges = fn
}
func Register_RenderEngine_EndEdges(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_EndEdges = fn
}
func Register_RenderEngine_BeginNode(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_BeginNode = fn
}
func Register_RenderEngine_EndNode(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_EndNode = fn
}
func Register_RenderEngine_BeginEdge(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_BeginEdge = fn
}
func Register_RenderEngine_EndEdge(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_EndEdge = fn
}
func Register_RenderEngine_BeginAnchor(fn func(*Job, string, string, string, string) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_BeginAnchor = fn
}
func Register_RenderEngine_EndAnchor(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_EndAnchor = fn
}
func Register_RenderEngine_BeginLabel(fn func(*Job, LabelType) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_BeginLabel = fn
}
func Register_RenderEngine_EndLabel(fn func(*Job) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_EndLabel = fn
}
func Register_RenderEngine_Textspan(fn func(*Job, *PointFloat, *Textspan) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_Textspan = fn
}
func Register_RenderEngine_ResolveColor(fn func(*Job, *Color) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_ResolveColor = fn
}
func Register_RenderEngine_Ellipse(fn func(*Job, []*PointFloat, int) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_Ellipse = fn
}
func Register_RenderEngine_Polygon(fn func(*Job, []*PointFloat, uint32, int) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_Polygon = fn
}
func Register_RenderEngine_Beziercurve(fn func(*Job, []*PointFloat, uint32, int) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_Beziercurve = fn
}
func Register_RenderEngine_Polyline(fn func(*Job, []*PointFloat, uint32) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_Polyline = fn
}
func Register_RenderEngine_Comment(fn func(*Job, string) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_Comment = fn
}
func Register_RenderEngine_LibraryShape(fn func(*Job, string, []*PointFloat, uint32, int) (uint64, error)) {
	mod.lookupFuncMap.RenderEngine_LibraryShape = fn
}
func Register_LayoutEngine_Layout(fn func(*Graph) (uint64, error)) {
	mod.lookupFuncMap.LayoutEngine_Layout = fn
}
func Register_LayoutEngine_Cleanup(fn func(*Graph) (uint64, error)) {
	mod.lookupFuncMap.LayoutEngine_Cleanup = fn
}
func Register_TextLayoutEngine_TextLayout(fn func(*Textspan, []string) (uint64, error)) {
	mod.lookupFuncMap.TextLayoutEngine_TextLayout = fn
}
func Register_LoadImageEngine_LoadImage(fn func(*Job, *UserShape, *BoxFloat, bool) (uint64, error)) {
	mod.lookupFuncMap.LoadImageEngine_LoadImage = fn
}

var mod *WasmModule

type CallbackFunc[T any] struct {
	cb     T
	funcID uint64
}

func CreateCallbackFunc[T any](cb T, funcID uint64) *CallbackFunc[T] {
	return &CallbackFunc[T]{
		cb:     cb,
		funcID: funcID,
	}
}

func init() {
	ctx := context.Background()
	cfg := wazero.NewRuntimeConfig()
	if cache := getCompilationCache(); cache != nil {
		cfg = cfg.WithCompilationCache(cache)
	}

	r := wazero.NewRuntimeWithConfig(ctx, cfg)

	env := r.NewHostModuleBuilder("env")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Graph, error) {
				var zero *Graph
				_ = zero
				ret := newGraph(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (*ClientDiscipline, error) {
				var zero *ClientDiscipline
				_ = zero
				ret := newClientDiscipline(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.IDAllocator_Open(arg0, arg1)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.IDAllocator_Open[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_IDAllocator_Open")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[2])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg3, err := func() (*uint64, error) {
				var zero *uint64
				_ = zero
				ret := new(uint64)
				value := mod.toUint64(stack[3])
				*ret = value
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg4, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[4])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.IDAllocator_Map(arg0, arg1, arg2, arg3, arg4)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.IDAllocator_Map[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1, arg2, arg3, arg4); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_IDAllocator_Map")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (uint64, error) {
				var zero uint64
				_ = zero
				ret := mod.toUint64(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.IDAllocator_Alloc(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.IDAllocator_Alloc[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI64},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_IDAllocator_Alloc")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (uint64, error) {
				var zero uint64
				_ = zero
				ret := mod.toUint64(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.IDAllocator_Free(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.IDAllocator_Free[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI64},
		[]api.ValueType{},
	).Export("wasm_bridge_IDAllocator_Free")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (uint64, error) {
				var zero uint64
				_ = zero
				ret := mod.toUint64(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.IDAllocator_Print(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.IDAllocator_Print[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI64},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_IDAllocator_Print")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.IDAllocator_Close(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.IDAllocator_Close[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_IDAllocator_Close")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.IDAllocator_IdRegister(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.IDAllocator_IdRegister[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_IDAllocator_IdRegister")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.IOService_Afread(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.IOService_Afread[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_IOService_Afread")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.IOService_Putstr(arg0, arg1)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.IOService_Putstr[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_IOService_Putstr")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.IOService_Flush(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.IOService_Flush[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_IOService_Flush")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Graph, error) {
				var zero *Graph
				_ = zero
				ret := newGraph(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (*Object, error) {
				var zero *Object
				_ = zero
				ret := newObject(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.ClientEventCallback_ObjectFunc(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.ClientEventCallback_ObjectFunc[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_ClientEventCallback_ObjectFunc")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Graph, error) {
				var zero *Graph
				_ = zero
				ret := newGraph(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (*Object, error) {
				var zero *Object
				_ = zero
				ret := newObject(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg3, err := func() (*Sym, error) {
				var zero *Sym
				_ = zero
				ret := newSym(stack[3])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.ClientEventCallback_ObjectUpdateFunc(arg0, arg1, arg2, arg3)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.ClientEventCallback_ObjectUpdateFunc[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2, arg3); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_ClientEventCallback_ObjectUpdateFunc")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[0])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.UserRef(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.UserRef[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_UserRef")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Dict, error) {
				var zero *Dict
				_ = zero
				ret := newDict(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (uint32, error) {
				var zero uint32
				_ = zero
				ret := mod.toUint32(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg3, err := func() (*DictDisc, error) {
				var zero *DictDisc
				_ = zero
				ret := newDictDisc(stack[3])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DictMemory(arg0, arg1, arg2, arg3)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DictMemory[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1, arg2, arg3); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_DictMemory")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Dict, error) {
				var zero *Dict
				_ = zero
				ret := newDict(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DictSearch(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DictSearch[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_DictSearch")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (*DictDisc, error) {
				var zero *DictDisc
				_ = zero
				ret := newDictDisc(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DictMake(arg0, arg1)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DictMake[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_DictMake")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DictFree(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DictFree[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DictFree")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DictCompare(arg0, arg1)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DictCompare[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_DictCompare")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (any, error) {
				var zero any
				_ = zero
				ret := mod.toAny(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DictWalk(arg0, arg1)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DictWalk[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_DictWalk")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*UserShape, error) {
				var zero *UserShape
				_ = zero
				ret := newUserShape(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.UserShape_DataFree(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.UserShape_DataFree[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_UserShape_DataFree")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceCallbacks_Refresh(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceCallbacks_Refresh[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceCallbacks_Refresh")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (*PointFloat, error) {
				var zero *PointFloat
				_ = zero
				ret := newPointFloat(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceCallbacks_ButtonPress(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceCallbacks_ButtonPress[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceCallbacks_ButtonPress")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (*PointFloat, error) {
				var zero *PointFloat
				_ = zero
				ret := newPointFloat(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceCallbacks_ButtonRelease(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceCallbacks_ButtonRelease[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceCallbacks_ButtonRelease")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (*PointFloat, error) {
				var zero *PointFloat
				_ = zero
				ret := newPointFloat(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceCallbacks_Motion(arg0, arg1)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceCallbacks_Motion[funcID]; exists {
				if err := fn(ctx, arg0, arg1); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceCallbacks_Motion")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[2])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceCallbacks_Modify(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceCallbacks_Modify[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceCallbacks_Modify")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceCallbacks_Delete(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceCallbacks_Delete[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceCallbacks_Delete")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[2])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceCallbacks_Read(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceCallbacks_Read[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceCallbacks_Read")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceCallbacks_Layout(arg0, arg1)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceCallbacks_Layout[funcID]; exists {
				if err := fn(ctx, arg0, arg1); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceCallbacks_Layout")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[2])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceCallbacks_Render(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceCallbacks_Render[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceCallbacks_Render")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceEngine_Initialize(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceEngine_Initialize[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceEngine_Initialize")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceEngine_Format(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceEngine_Format[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceEngine_Format")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.DeviceEngine_Finalize(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.DeviceEngine_Finalize[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_DeviceEngine_Finalize")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_BeginJob(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_BeginJob[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_BeginJob")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_EndJob(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_EndJob[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_EndJob")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_BeginGraph(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_BeginGraph[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_BeginGraph")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_EndGraph(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_EndGraph[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_EndGraph")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg3, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[3])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_BeginLayer(arg0, arg1, arg2, arg3)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_BeginLayer[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2, arg3); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_BeginLayer")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_EndLayer(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_EndLayer[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_EndLayer")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_BeginPage(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_BeginPage[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_BeginPage")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_EndPage(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_EndPage[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_EndPage")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_BeginCluster(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_BeginCluster[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_BeginCluster")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_EndCluster(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_EndCluster[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_EndCluster")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_BeginNodes(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_BeginNodes[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_BeginNodes")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_EndNodes(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_EndNodes[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_EndNodes")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_BeginEdges(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_BeginEdges[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_BeginEdges")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_EndEdges(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_EndEdges[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_EndEdges")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_BeginNode(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_BeginNode[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_BeginNode")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_EndNode(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_EndNode[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_EndNode")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_BeginEdge(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_BeginEdge[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_BeginEdge")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_EndEdge(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_EndEdge[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_EndEdge")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[2])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg3, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[3])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg4, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[4])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_BeginAnchor(arg0, arg1, arg2, arg3, arg4)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_BeginAnchor[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2, arg3, arg4); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_BeginAnchor")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_EndAnchor(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_EndAnchor[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_EndAnchor")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (LabelType, error) {
				var zero LabelType
				_ = zero
				ret := LabelType(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_BeginLabel(arg0, arg1)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_BeginLabel[funcID]; exists {
				if err := fn(ctx, arg0, arg1); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_BeginLabel")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_EndLabel(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_EndLabel[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_EndLabel")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (*PointFloat, error) {
				var zero *PointFloat
				_ = zero
				ret := newPointFloat(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (*Textspan, error) {
				var zero *Textspan
				_ = zero
				ret := newTextspan(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_Textspan(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_Textspan[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_Textspan")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (*Color, error) {
				var zero *Color
				_ = zero
				ret := newColor(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_ResolveColor(arg0, arg1)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_ResolveColor[funcID]; exists {
				if err := fn(ctx, arg0, arg1); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_ResolveColor")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() ([]*PointFloat, error) {
				var zero []*PointFloat
				_ = zero
				slice, err := mod.toSlice(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				ret := newPointFloatSlice(slice)
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_Ellipse(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_Ellipse[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_Ellipse")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() ([]*PointFloat, error) {
				var zero []*PointFloat
				_ = zero
				slice, err := mod.toSlice(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				ret := newPointFloatSlice(slice)
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (uint32, error) {
				var zero uint32
				_ = zero
				ret := mod.toUint32(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg3, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[3])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_Polygon(arg0, arg1, arg2, arg3)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_Polygon[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2, arg3); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_Polygon")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() ([]*PointFloat, error) {
				var zero []*PointFloat
				_ = zero
				slice, err := mod.toSlice(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				ret := newPointFloatSlice(slice)
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (uint32, error) {
				var zero uint32
				_ = zero
				ret := mod.toUint32(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg3, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[3])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_Beziercurve(arg0, arg1, arg2, arg3)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_Beziercurve[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2, arg3); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_Beziercurve")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() ([]*PointFloat, error) {
				var zero []*PointFloat
				_ = zero
				slice, err := mod.toSlice(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				ret := newPointFloatSlice(slice)
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (uint32, error) {
				var zero uint32
				_ = zero
				ret := mod.toUint32(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_Polyline(arg0, arg1, arg2)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_Polyline[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_Polyline")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_Comment(arg0, arg1)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_Comment[funcID]; exists {
				if err := fn(ctx, arg0, arg1); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_Comment")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (string, error) {
				var zero string
				_ = zero
				ret, err := mod.toString(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() ([]*PointFloat, error) {
				var zero []*PointFloat
				_ = zero
				slice, err := mod.toSlice(ctx, stack[2])
				if err != nil {
					return zero, err
				}
				ret := newPointFloatSlice(slice)
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg3, err := func() (uint32, error) {
				var zero uint32
				_ = zero
				ret := mod.toUint32(stack[3])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg4, err := func() (int, error) {
				var zero int
				_ = zero
				ret := mod.toInt(stack[4])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.RenderEngine_LibraryShape(arg0, arg1, arg2, arg3, arg4)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.RenderEngine_LibraryShape[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2, arg3, arg4); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_RenderEngine_LibraryShape")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Graph, error) {
				var zero *Graph
				_ = zero
				ret := newGraph(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.LayoutEngine_Layout(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.LayoutEngine_Layout[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_LayoutEngine_Layout")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Graph, error) {
				var zero *Graph
				_ = zero
				ret := newGraph(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.LayoutEngine_Cleanup(arg0)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.LayoutEngine_Cleanup[funcID]; exists {
				if err := fn(ctx, arg0); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_LayoutEngine_Cleanup")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Textspan, error) {
				var zero *Textspan
				_ = zero
				ret := newTextspan(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() ([]string, error) {
				var zero []string
				_ = zero
				slice, err := mod.toSlice(ctx, stack[1])
				if err != nil {
					return zero, err
				}
				ret, err := mod.toStringSlice(ctx, slice)
				if err != nil {
					return zero, err
				}
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.TextLayoutEngine_TextLayout(arg0, arg1)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.TextLayoutEngine_TextLayout[funcID]; exists {
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, arg0, arg1); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{api.ValueTypeI32},
	).Export("wasm_bridge_TextLayoutEngine_TextLayout")
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			arg0, err := func() (*Job, error) {
				var zero *Job
				_ = zero
				ret := newJob(stack[0])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg1, err := func() (*UserShape, error) {
				var zero *UserShape
				_ = zero
				ret := newUserShape(stack[1])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg2, err := func() (*BoxFloat, error) {
				var zero *BoxFloat
				_ = zero
				ret := newBoxFloat(stack[2])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}
			arg3, err := func() (bool, error) {
				var zero bool
				_ = zero
				ret := mod.toBool(stack[3])
				return ret, nil
			}()
			if err != nil {
				panic(err)
			}

			funcID, err := mod.lookupFuncMap.LoadImageEngine_LoadImage(arg0, arg1, arg2, arg3)
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.LoadImageEngine_LoadImage[funcID]; exists {
				if err := fn(ctx, arg0, arg1, arg2, arg3); err != nil {
					panic(err)
				}
			}
		}),
		[]api.ValueType{api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32, api.ValueTypeI32},
		[]api.ValueType{},
	).Export("wasm_bridge_LoadImageEngine_LoadImage")
	if _, err := env.Instantiate(ctx); err != nil {
		panic(err)
	}
	wasi_snapshot_preview1.MustInstantiate(ctx, r)

	compiled, err := r.CompileModule(ctx, wasmFile)
	if err != nil {
		panic(err)
	}
	dir, err := os.MkdirTemp("", "graphviz")
	if err != nil {
		panic(err)
	}
	m, err := r.InstantiateModule(
		ctx,
		compiled,
		wazero.NewModuleConfig().
			WithFSConfig(wazero.NewFSConfig().WithDirMount(dir, "/")).
			WithStdout(os.Stdout).
			WithName("wasi"),
	)
	if err != nil {
		panic(err)
	}
	mod = &WasmModule{
		mod:           m,
		lookupFuncMap: &LookupFuncMap{},
		callbackFuncMap: &CallbackFuncMap{
			IDAllocator_Open:                     make(map[uint64]func(context.Context, *Graph, *ClientDiscipline) (any, error)),
			IDAllocator_Map:                      make(map[uint64]func(context.Context, any, int, string, *uint64, int) (int32, error)),
			IDAllocator_Alloc:                    make(map[uint64]func(context.Context, any, int, uint64) (int32, error)),
			IDAllocator_Free:                     make(map[uint64]func(context.Context, any, int, uint64) error),
			IDAllocator_Print:                    make(map[uint64]func(context.Context, any, int, uint64) (string, error)),
			IDAllocator_Close:                    make(map[uint64]func(context.Context, any) error),
			IDAllocator_IdRegister:               make(map[uint64]func(context.Context, any, int, any) error),
			IOService_Afread:                     make(map[uint64]func(context.Context, any, string, int) (int, error)),
			IOService_Putstr:                     make(map[uint64]func(context.Context, any, string) (int, error)),
			IOService_Flush:                      make(map[uint64]func(context.Context, any) (int, error)),
			ClientEventCallback_ObjectFunc:       make(map[uint64]func(context.Context, *Graph, *Object, any) error),
			ClientEventCallback_ObjectUpdateFunc: make(map[uint64]func(context.Context, *Graph, *Object, any, *Sym) error),
			UserRef:                              make(map[uint64]func(context.Context, string) (int, error)),
			DictMemory:                           make(map[uint64]func(context.Context, *Dict, any, uint32, *DictDisc) (any, error)),
			DictSearch:                           make(map[uint64]func(context.Context, *Dict, any, int) (any, error)),
			DictMake:                             make(map[uint64]func(context.Context, any, *DictDisc) (any, error)),
			DictFree:                             make(map[uint64]func(context.Context, any) error),
			DictCompare:                          make(map[uint64]func(context.Context, any, any) (int, error)),
			DictWalk:                             make(map[uint64]func(context.Context, any, any) (int, error)),
			UserShape_DataFree:                   make(map[uint64]func(context.Context, *UserShape) error),
			DeviceCallbacks_Refresh:              make(map[uint64]func(context.Context, *Job) error),
			DeviceCallbacks_ButtonPress:          make(map[uint64]func(context.Context, *Job, int, *PointFloat) error),
			DeviceCallbacks_ButtonRelease:        make(map[uint64]func(context.Context, *Job, int, *PointFloat) error),
			DeviceCallbacks_Motion:               make(map[uint64]func(context.Context, *Job, *PointFloat) error),
			DeviceCallbacks_Modify:               make(map[uint64]func(context.Context, *Job, string, string) error),
			DeviceCallbacks_Delete:               make(map[uint64]func(context.Context, *Job) error),
			DeviceCallbacks_Read:                 make(map[uint64]func(context.Context, *Job, string, string) error),
			DeviceCallbacks_Layout:               make(map[uint64]func(context.Context, *Job, string) error),
			DeviceCallbacks_Render:               make(map[uint64]func(context.Context, *Job, string, string) error),
			DeviceEngine_Initialize:              make(map[uint64]func(context.Context, *Job) error),
			DeviceEngine_Format:                  make(map[uint64]func(context.Context, *Job) error),
			DeviceEngine_Finalize:                make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_BeginJob:                make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_EndJob:                  make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_BeginGraph:              make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_EndGraph:                make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_BeginLayer:              make(map[uint64]func(context.Context, *Job, string, int, int) error),
			RenderEngine_EndLayer:                make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_BeginPage:               make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_EndPage:                 make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_BeginCluster:            make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_EndCluster:              make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_BeginNodes:              make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_EndNodes:                make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_BeginEdges:              make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_EndEdges:                make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_BeginNode:               make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_EndNode:                 make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_BeginEdge:               make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_EndEdge:                 make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_BeginAnchor:             make(map[uint64]func(context.Context, *Job, string, string, string, string) error),
			RenderEngine_EndAnchor:               make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_BeginLabel:              make(map[uint64]func(context.Context, *Job, LabelType) error),
			RenderEngine_EndLabel:                make(map[uint64]func(context.Context, *Job) error),
			RenderEngine_Textspan:                make(map[uint64]func(context.Context, *Job, *PointFloat, *Textspan) error),
			RenderEngine_ResolveColor:            make(map[uint64]func(context.Context, *Job, *Color) error),
			RenderEngine_Ellipse:                 make(map[uint64]func(context.Context, *Job, []*PointFloat, int) error),
			RenderEngine_Polygon:                 make(map[uint64]func(context.Context, *Job, []*PointFloat, uint32, int) error),
			RenderEngine_Beziercurve:             make(map[uint64]func(context.Context, *Job, []*PointFloat, uint32, int) error),
			RenderEngine_Polyline:                make(map[uint64]func(context.Context, *Job, []*PointFloat, uint32) error),
			RenderEngine_Comment:                 make(map[uint64]func(context.Context, *Job, string) error),
			RenderEngine_LibraryShape:            make(map[uint64]func(context.Context, *Job, string, []*PointFloat, uint32, int) error),
			LayoutEngine_Layout:                  make(map[uint64]func(context.Context, *Graph) error),
			LayoutEngine_Cleanup:                 make(map[uint64]func(context.Context, *Graph) error),
			TextLayoutEngine_TextLayout:          make(map[uint64]func(context.Context, *Textspan, []string) (bool, error)),
			LoadImageEngine_LoadImage:            make(map[uint64]func(context.Context, *Job, *UserShape, *BoxFloat, bool) error),
		},
	}
	// bind ObjectTag values.
	GRAPH = ObjectTag(mod.getEnumValue(ctx, "AGRAPH"))
	NODE = ObjectTag(mod.getEnumValue(ctx, "AGNODE"))
	OUT_EDGE = ObjectTag(mod.getEnumValue(ctx, "AGOUTEDGE"))
	IN_EDGE = ObjectTag(mod.getEnumValue(ctx, "AGINEDGE"))
	EDGE = ObjectTag(mod.getEnumValue(ctx, "AGEDGE"))
	// bind ErrorLevel values.
	WARN = ErrorLevel(mod.getEnumValue(ctx, "AGWARN"))
	ERR = ErrorLevel(mod.getEnumValue(ctx, "AGERR"))
	MAX = ErrorLevel(mod.getEnumValue(ctx, "AGMAX"))
	PREV = ErrorLevel(mod.getEnumValue(ctx, "AGPREV"))
	// bind ImageType values.
	IMAGE_TYPE_NULL = ImageType(mod.getEnumValue(ctx, "FT_NULL"))
	IMAGE_TYPE_BMP = ImageType(mod.getEnumValue(ctx, "FT_BMP"))
	IMAGE_TYPE_GIF = ImageType(mod.getEnumValue(ctx, "FT_GIF"))
	IMAGE_TYPE_PNG = ImageType(mod.getEnumValue(ctx, "FT_PNG"))
	IMAGE_TYPE_JPEG = ImageType(mod.getEnumValue(ctx, "FT_JPEG"))
	IMAGE_TYPE_PDF = ImageType(mod.getEnumValue(ctx, "FT_PDF"))
	IMAGE_TYPE_PS = ImageType(mod.getEnumValue(ctx, "FT_PS"))
	IMAGE_TYPE_EPS = ImageType(mod.getEnumValue(ctx, "FT_EPS"))
	IMAGE_TYPE_SVG = ImageType(mod.getEnumValue(ctx, "FT_SVG"))
	IMAGE_TYPE_XML = ImageType(mod.getEnumValue(ctx, "FT_XML"))
	IMAGE_TYPE_RIFF = ImageType(mod.getEnumValue(ctx, "FT_RIFF"))
	IMAGE_TYPE_WEBP = ImageType(mod.getEnumValue(ctx, "FT_WEBP"))
	IMAGE_TYPE_ICO = ImageType(mod.getEnumValue(ctx, "FT_ICO"))
	IMAGE_TYPE_TIFF = ImageType(mod.getEnumValue(ctx, "FT_TIFF"))
	// bind ObjectType values.
	ROOTGRAPH_OBJTYPE = ObjectType(mod.getEnumValue(ctx, "ROOTGRAPH_OBJTYPE"))
	CLUSTER_OBJTYPE = ObjectType(mod.getEnumValue(ctx, "CLUSTER_OBJTYPE"))
	NODE_OBJTYPE = ObjectType(mod.getEnumValue(ctx, "NODE_OBJTYPE"))
	EDGE_OBJTYPE = ObjectType(mod.getEnumValue(ctx, "EDGE_OBJTYPE"))
	// bind MapShapeType values.
	MAP_RECTANGLE = MapShapeType(mod.getEnumValue(ctx, "MAP_RECTANGLE"))
	MAP_CIRCLE = MapShapeType(mod.getEnumValue(ctx, "MAP_CIRCLE"))
	MAP_POLYGON = MapShapeType(mod.getEnumValue(ctx, "MAP_POLYGON"))
	// bind EmitState values.
	EMIT_GDRAW = EmitState(mod.getEnumValue(ctx, "EMIT_GDRAW"))
	EMIT_CDRAW = EmitState(mod.getEnumValue(ctx, "EMIT_CDRAW"))
	EMIT_TDRAW = EmitState(mod.getEnumValue(ctx, "EMIT_TDRAW"))
	EMIT_HDRAW = EmitState(mod.getEnumValue(ctx, "EMIT_HDRAW"))
	EMIT_GLABEL = EmitState(mod.getEnumValue(ctx, "EMIT_GLABEL"))
	EMIT_CLABEL = EmitState(mod.getEnumValue(ctx, "EMIT_CLABEL"))
	EMIT_TLABEL = EmitState(mod.getEnumValue(ctx, "EMIT_TLABEL"))
	EMIT_HLABEL = EmitState(mod.getEnumValue(ctx, "EMIT_HLABEL"))
	EMIT_NDRAW = EmitState(mod.getEnumValue(ctx, "EMIT_NDRAW"))
	EMIT_EDRAW = EmitState(mod.getEnumValue(ctx, "EMIT_EDRAW"))
	EMIT_NLABEL = EmitState(mod.getEnumValue(ctx, "EMIT_NLABEL"))
	EMIT_ELABEL = EmitState(mod.getEnumValue(ctx, "EMIT_ELABEL"))
	// bind EmitType values.
	EMIT_SORTED = EmitType(mod.getEnumValue(ctx, "EMIT_SORTED"))
	EMIT_COLORS = EmitType(mod.getEnumValue(ctx, "EMIT_COLORS"))
	EMIT_CLUSTERS_LAST = EmitType(mod.getEnumValue(ctx, "EMIT_CLUSTERS_LAST"))
	EMIT_PREORDER = EmitType(mod.getEnumValue(ctx, "EMIT_PREORDER"))
	EMIT_EDGE_SORTED = EmitType(mod.getEnumValue(ctx, "EMIT_EDGE_SORTED"))
	// bind DeviceType values.
	DEVICE_DOES_PAGES = DeviceType(mod.getEnumValue(ctx, "GVDEVICE_DOES_PAGES"))
	DEVICE_DOES_LAYERS = DeviceType(mod.getEnumValue(ctx, "GVDEVICE_DOES_LAYERS"))
	DEVICE_EVENTS = DeviceType(mod.getEnumValue(ctx, "GVDEVICE_EVENTS"))
	DEVICE_DOES_TRUECOLOR = DeviceType(mod.getEnumValue(ctx, "GVDEVICE_DOES_TRUECOLOR"))
	DEVICE_BINARY_FORMAT = DeviceType(mod.getEnumValue(ctx, "GVDEVICE_BINARY_FORMAT"))
	DEVICE_COMPRESSED_FORMAT = DeviceType(mod.getEnumValue(ctx, "GVDEVICE_COMPRESSED_FORMAT"))
	DEVICE_NO_WRITER = DeviceType(mod.getEnumValue(ctx, "GVDEVICE_NO_WRITER"))
	// bind RenderType values.
	RENDER_Y_GOES_DOWN = RenderType(mod.getEnumValue(ctx, "GVRENDER_Y_GOES_DOWN"))
	RENDER_DOES_TRANSFORM = RenderType(mod.getEnumValue(ctx, "GVRENDER_DOES_TRANSFORM"))
	RENDER_DOES_LABELS = RenderType(mod.getEnumValue(ctx, "GVRENDER_DOES_LABELS"))
	RENDER_DOES_MAPS = RenderType(mod.getEnumValue(ctx, "GVRENDER_DOES_MAPS"))
	RENDER_DOES_MAP_RECTANGLE = RenderType(mod.getEnumValue(ctx, "GVRENDER_DOES_MAP_RECTANGLE"))
	RENDER_DOES_MAP_CIRCLE = RenderType(mod.getEnumValue(ctx, "GVRENDER_DOES_MAP_CIRCLE"))
	RENDER_DOES_MAP_POLYGON = RenderType(mod.getEnumValue(ctx, "GVRENDER_DOES_MAP_POLYGON"))
	RENDER_DOES_MAP_ELLIPSE = RenderType(mod.getEnumValue(ctx, "GVRENDER_DOES_MAP_ELLIPSE"))
	RENDER_DOES_MAP_BSPLINE = RenderType(mod.getEnumValue(ctx, "GVRENDER_DOES_MAP_BSPLINE"))
	RENDER_DOES_TOOLTIPS = RenderType(mod.getEnumValue(ctx, "GVRENDER_DOES_TOOLTIPS"))
	RENDER_DOES_TARGETS = RenderType(mod.getEnumValue(ctx, "GVRENDER_DOES_TARGETS"))
	RENDER_DOES_Z = RenderType(mod.getEnumValue(ctx, "GVRENDER_DOES_Z"))
	RENDER_NO_WHITE_BG = RenderType(mod.getEnumValue(ctx, "GVRENDER_NO_WHITE_BG"))
	// bind RequiredType values.
	LAYOUT_NOT_REQUIRED = RequiredType(mod.getEnumValue(ctx, "LAYOUT_NOT_REQUIRED"))
	OUTPUT_NOT_REQUIRED = RequiredType(mod.getEnumValue(ctx, "OUTPUT_NOT_REQUIRED"))
	// bind PenType values.
	PEN_NONE = PenType(mod.getEnumValue(ctx, "PEN_NONE"))
	PEN_DASHED = PenType(mod.getEnumValue(ctx, "PEN_DASHED"))
	PEN_DOTTED = PenType(mod.getEnumValue(ctx, "PEN_DOTTED"))
	PEN_SOLID = PenType(mod.getEnumValue(ctx, "PEN_SOLID"))
	// bind FillType values.
	FILL_NONE = FillType(mod.getEnumValue(ctx, "FILL_NONE"))
	FILL_SOLID = FillType(mod.getEnumValue(ctx, "FILL_SOLID"))
	FILL_LINEAR = FillType(mod.getEnumValue(ctx, "FILL_LINEAR"))
	FILL_RADIAL = FillType(mod.getEnumValue(ctx, "FILL_RADIAL"))
	// bind FontType values.
	FONT_REGULAR = FontType(mod.getEnumValue(ctx, "FONT_REGULAR"))
	FONT_BOLD = FontType(mod.getEnumValue(ctx, "FONT_BOLD"))
	FONT_ITALIC = FontType(mod.getEnumValue(ctx, "FONT_ITALIC"))
	// bind LabelType values.
	LABEL_PLAIN = LabelType(mod.getEnumValue(ctx, "LABEL_PLAIN"))
	LABEL_HTML = LabelType(mod.getEnumValue(ctx, "LABEL_HTML"))
	// bind ColorType values.
	HSVA_DOUBLE = ColorType(mod.getEnumValue(ctx, "HSVA_DOUBLE"))
	RGBA_BYTE = ColorType(mod.getEnumValue(ctx, "RGBA_BYTE"))
	RGBA_WORD = ColorType(mod.getEnumValue(ctx, "RGBA_WORD"))
	RGBA_DOUBLE = ColorType(mod.getEnumValue(ctx, "RGBA_DOUBLE"))
	COLOR_STRING = ColorType(mod.getEnumValue(ctx, "COLOR_STRING"))
	COLOR_INDEX = ColorType(mod.getEnumValue(ctx, "COLOR_INDEX"))
	// bind API values.
	API_RENDER = API(mod.getEnumValue(ctx, "API_render"))
	API_LAYOUT = API(mod.getEnumValue(ctx, "API_layout"))
	API_TEXTLAYOUT = API(mod.getEnumValue(ctx, "API_textlayout"))
	API_DEVICE = API(mod.getEnumValue(ctx, "API_device"))
	API_LOADIMAGE = API(mod.getEnumValue(ctx, "API_loadimage"))
}

func (m *WasmModule) getEnumValue(ctx context.Context, value string) int {
	ret, err := mod.ExportedFunction("wasm_bridge_get_" + value).Call(ctx)
	if err != nil {
		panic(err)
	}
	return mod.toInt(ret[0])
}

func WasmPtr(v wasmStruct) uint64 {
	return v.getPtr()
}

func getCompilationCache() wazero.CompilationCache {
	return nil
	tmpDir := os.TempDir()
	if tmpDir == "" {
		return nil
	}
	cacheDir := filepath.Join(tmpDir, "go-graphviz")
	if _, err := os.Stat(cacheDir); err != nil {
		if err := os.Mkdir(cacheDir, 0o755); err != nil {
			return nil
		}
	}
	cache, err := wazero.NewCompilationCacheWithDir(cacheDir)
	if err != nil {
		return nil
	}
	return cache
}

func (m *WasmModule) ExportedFunction(name string) api.Function {
	return m.mod.ExportedFunction(name)
}

func (m *WasmModule) malloc(ctx context.Context, size uint64) (uint64, error) {
	ret, err := m.ExportedFunction("malloc").Call(ctx, size)
	if err != nil {
		return 0, err
	}
	return ret[0], nil
}

func (m *WasmModule) free(ctx context.Context, p uint64) error {
	if _, err := m.ExportedFunction("free").Call(ctx, p); err != nil {
		return err
	}
	return nil
}

func (m *WasmModule) newObject(ctx context.Context, name string) (uint64, error) {
	ret, err := mod.ExportedFunction("wasm_bridge_new_" + name).Call(ctx)
	if err != nil {
		return 0, err
	}
	return ret[0], nil
}

func (m *WasmModule) setField(ctx context.Context, name string, recv, arg uint64) error {
	if _, err := mod.ExportedFunction("wasm_bridge_set_"+name).Call(ctx, recv, arg); err != nil {
		return err
	}
	return nil
}

func (m *WasmModule) setFieldFunction(ctx context.Context, name string, recv uint64) error {
	if _, err := mod.ExportedFunction("wasm_bridge_set_"+name).Call(ctx, recv); err != nil {
		return err
	}
	return nil
}

func (m *WasmModule) getField(ctx context.Context, name string, recv uint64) (ret uint64, e error) {
	retPtr, err := m.NewPtr(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		e = m.free(ctx, retPtr)
	}()

	if _, err := m.ExportedFunction("wasm_bridge_get_"+name).Call(ctx, recv, retPtr); err != nil {
		return 0, err
	}
	p, err := m.readU32(retPtr)
	if err != nil {
		return 0, err
	}
	return p, nil
}

func (m *WasmModule) call(ctx context.Context, name string, args ...uint64) error {
	if _, err := mod.ExportedFunction("wasm_bridge_"+name).Call(ctx, args...); err != nil {
		return err
	}
	return nil
}

func (m *WasmModule) callWithRet(ctx context.Context, name string, args ...uint64) (r uint64, e error) {
	retPtr, err := m.NewPtr(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		e = m.free(ctx, retPtr)
	}()

	if err := m.call(ctx, name, append(append([]uint64{}, args...), retPtr)...); err != nil {
		return 0, err
	}
	p, err := m.readU32(retPtr)
	if err != nil {
		return 0, err
	}
	return p, nil
}

func (m *WasmModule) read(addr, length uint64) ([]byte, error) {
	bytes, ok := m.mod.Memory().Read(uint32(addr), uint32(length))
	if !ok {
		return nil, fmt.Errorf(
			`failed to read wasm memory: (ptr, size) = (%d, %d) and memory size is %d`,
			addr, length, m.mod.Memory().Size(),
		)
	}
	return bytes, nil
}

func (m *WasmModule) readU32(addr uint64) (uint64, error) {
	p, ok := m.mod.Memory().ReadUint32Le(uint32(addr))
	if !ok {
		return 0, fmt.Errorf(
			`failed to read wasm memory: (ptr, size) = (%d, 4) and memory size is %d`,
			addr, m.mod.Memory().Size(),
		)
	}
	return uint64(p), nil
}

func (m *WasmModule) write(p uint64, b []byte) error {
	if !m.mod.Memory().Write(uint32(p), b) {
		return fmt.Errorf(
			`failed to write wasm memory: (ptr, size) = (%d, %d) and memory size is %d`,
			p, len(b), m.mod.Memory().Size(),
		)
	}
	return nil
}

func (m *WasmModule) writeU32(p uint64, v uint32) error {
	if !m.mod.Memory().WriteUint32Le(uint32(p), v) {
		return fmt.Errorf(
			`failed to write wasm memory: ptr = %d and memory size is %d`,
			p, m.mod.Memory().Size(),
		)
	}
	return nil
}

func (m *WasmModule) writeU64(p uint64, v uint64) error {
	if !m.mod.Memory().WriteUint64Le(uint32(p), v) {
		return fmt.Errorf(
			`failed to write wasm memory: ptr = %d and memory size is %d`,
			p, m.mod.Memory().Size(),
		)
	}
	return nil
}

func (m *WasmModule) writeF64(p uint64, v float64) error {
	if !m.mod.Memory().WriteFloat64Le(uint32(p), v) {
		return fmt.Errorf(
			`failed to write wasm memory: ptr = %d and memory size is %d`,
			p, m.mod.Memory().Size(),
		)
	}
	return nil
}

func (m *WasmModule) NewPtr(ctx context.Context) (uint64, error) {
	return m.malloc(ctx, 4)
}

func (m *WasmModule) toSlice(ctx context.Context, p uint64) ([]uint64, error) {
	length, err := m.readU32(p)
	if err != nil {
		return nil, err
	}
	data, err := m.readU32(p + 4)
	if err != nil {
		return nil, err
	}
	var ret []uint64
	for i := uint64(0); i < length; i++ {
		p, err := m.readU32(data + 8*i)
		if err != nil {
			return nil, err
		}
		ret = append(ret, p)
	}
	return ret, nil
}

func (m *WasmModule) toBool(p uint64) bool {
	if p == 1 {
		return true
	}
	return false
}

func (m *WasmModule) toBoolSlice(v []uint64) []bool {
	var ret []bool
	for _, vv := range v {
		ret = append(ret, m.toBool(vv))
	}
	return ret
}

func (m *WasmModule) toFloat32(ctx context.Context, p uint64) (float32, error) {
	v, err := m.toString(ctx, p)
	if err != nil {
		return 0, err
	}
	f64, err := strconv.ParseFloat(v, 64)
	if err != nil {
		return 0, err
	}
	return float32(f64), nil
}

func (m *WasmModule) toFloat32Slice(ctx context.Context, v []uint64) ([]float32, error) {
	var ret []float32
	for _, vv := range v {
		f, err := m.toFloat32(ctx, vv)
		if err != nil {
			return nil, err
		}
		ret = append(ret, f)
	}
	return ret, nil
}

func (m *WasmModule) toFloat64(ctx context.Context, p uint64) (float64, error) {
	v, err := m.toString(ctx, p)
	if err != nil {
		return 0, err
	}
	f64, err := strconv.ParseFloat(v, 64)
	if err != nil {
		return 0, err
	}
	return f64, nil
}

func (m *WasmModule) toFloat64Slice(ctx context.Context, v []uint64) ([]float64, error) {
	var ret []float64
	for _, vv := range v {
		f, err := m.toFloat64(ctx, vv)
		if err != nil {
			return nil, err
		}
		ret = append(ret, f)
	}
	return ret, nil
}

func (m *WasmModule) toInt(p uint64) int {
	return int(p)
}

func (m *WasmModule) toIntSlice(v []uint64) []int {
	var ret []int
	for _, vv := range v {
		ret = append(ret, m.toInt(vv))
	}
	return ret
}

func (m *WasmModule) toInt32(v uint64) int32 {
	return int32(v)
}

func (m *WasmModule) toInt32Slice(v []uint64) []int32 {
	var ret []int32
	for _, vv := range v {
		ret = append(ret, m.toInt32(vv))
	}
	return ret
}

func (m *WasmModule) toInt64(v uint64) int64 {
	return int64(v)
}

func (m *WasmModule) toInt64Slice(v []uint64) []int64 {
	var ret []int64
	for _, vv := range v {
		ret = append(ret, m.toInt64(vv))
	}
	return ret
}

func (m *WasmModule) toUint(p uint64) uint {
	return uint(p)
}

func (m *WasmModule) toUintSlice(v []uint64) []uint {
	var ret []uint
	for _, vv := range v {
		ret = append(ret, m.toUint(vv))
	}
	return ret
}

func (m *WasmModule) toUint32(v uint64) uint32 {
	return uint32(v)
}

func (m *WasmModule) toUint32Slice(v []uint64) []uint32 {
	var ret []uint32
	for _, vv := range v {
		ret = append(ret, m.toUint32(vv))
	}
	return ret
}

func (m *WasmModule) toUint64(v uint64) uint64 {
	return v
}

func (m *WasmModule) toUint64Slice(v []uint64) []uint64 {
	return v
}

func (m *WasmModule) toAny(v uint64) any {
	return v
}

func (m *WasmModule) toString(ctx context.Context, p uint64) (string, error) {
	if p == 0 {
		return "", nil
	}
	dataAddr, err := m.readU32(p)
	if err != nil {
		return "", err
	}
	length, err := m.readU32(p + 4)
	if err != nil {
		return "", err
	}
	if length == 0 {
		return "", nil
	}
	bytes, err := m.read(dataAddr, length)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

func (m *WasmModule) toStringSlice(ctx context.Context, v []uint64) ([]string, error) {
	var ret []string
	for _, vv := range v {
		s, err := m.toString(ctx, vv)
		if err != nil {
			return nil, err
		}
		ret = append(ret, s)
	}
	return ret, nil
}

func (m *WasmModule) toObjectWasmValue(_ context.Context, v wasmStruct) (uint64, error) {
	return v.getPtr(), nil
}

func (m *WasmModule) toAnyWasmValue(_ context.Context, v any) (uint64, error) {
	switch vv := v.(type) {
	case wasmStruct:
		return vv.getPtr(), nil
	}
	return 0, nil
}

func (m *WasmModule) toPtrWasmValue(ctx context.Context, _ any) (uint64, error) {
	return m.NewPtr(ctx)
}

type wasmStruct interface {
	getPtr() uint64
}

type numberType interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

func (m *WasmModule) toIntWasmValue(_ context.Context, v any) (uint64, error) {
	switch vv := v.(type) {
	case int:
		return uint64(vv), nil
	case int8:
		return uint64(vv), nil
	case int16:
		return uint64(vv), nil
	case int32:
		return uint64(vv), nil
	case int64:
		return uint64(vv), nil
	}
	return uint64(reflect.ValueOf(v).Int()), nil
}

func (m *WasmModule) toInt32WasmValue(_ context.Context, v int32) (uint64, error) {
	return uint64(v), nil
}

func (m *WasmModule) toInt64WasmValue(_ context.Context, v int64) (uint64, error) {
	return uint64(v), nil
}

func (m *WasmModule) toUintWasmValue(_ context.Context, v any) (uint64, error) {
	switch vv := v.(type) {
	case uint:
		return uint64(vv), nil
	case uint8:
		return uint64(vv), nil
	case uint16:
		return uint64(vv), nil
	case uint32:
		return uint64(vv), nil
	case uint64:
		return vv, nil
	}
	return 0, nil
}

func (m *WasmModule) toUint32WasmValue(_ context.Context, v uint32) (uint64, error) {
	return uint64(v), nil
}

func (m *WasmModule) toUint64WasmValue(_ context.Context, v uint64) (uint64, error) {
	return v, nil
}

func (m *WasmModule) toBoolWasmValue(_ context.Context, v bool) (uint64, error) {
	if v {
		return 1, nil
	}
	return 0, nil
}

func (m *WasmModule) toFuncWasmValue(_ context.Context, _ any) (uint64, error) {
	return 0, nil
}

func (m *WasmModule) toFloatWasmValue(_ context.Context, v float32) (uint64, error) {
	return api.EncodeF32(v), nil
}

func (m *WasmModule) toDoubleWasmValue(_ context.Context, v float64) (uint64, error) {
	return api.EncodeF64(v), nil
}

func (m *WasmModule) toIntArrayWasmValue(ctx context.Context, v []int) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, uint64(vv)); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toInt32ArrayWasmValue(ctx context.Context, v []int32) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, uint64(vv)); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toInt64ArrayWasmValue(ctx context.Context, v []int64) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, uint64(vv)); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toUintArrayWasmValue(ctx context.Context, v []uint) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, uint64(vv)); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toUint32ArrayWasmValue(ctx context.Context, v []uint32) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, uint64(vv)); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toUint64ArrayWasmValue(ctx context.Context, v []uint64) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, vv); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toDoubleArrayWasmValue(ctx context.Context, v []float64) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeF64(ptr, vv); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toFloatStringWasmValue(ctx context.Context, v float32) (uint64, error) {
	return m.toStringWasmValue(ctx, fmt.Sprint(v))
}

func (m *WasmModule) toDoubleStringWasmValue(ctx context.Context, v float64) (uint64, error) {
	return m.toStringWasmValue(ctx, fmt.Sprint(v))
}

func (m *WasmModule) toFloatStringArrayWasmValue(ctx context.Context, v []float32) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		f, err := m.toFloatStringWasmValue(ctx, vv)
		if err != nil {
			return 0, err
		}
		if err := m.writeU64(ptr, f); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toDoubleStringArrayWasmValue(ctx context.Context, v []float64) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		f, err := m.toDoubleStringWasmValue(ctx, vv)
		if err != nil {
			return 0, err
		}
		if err := m.writeU64(ptr, f); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toStringWasmValue(ctx context.Context, s string) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(len(s))+1)
	if err != nil {
		return 0, err
	}
	if err := m.write(ret, append([]byte(s), 0)); err != nil {
		return 0, err
	}
	return ret, nil
}

func (m *WasmModule) toStringArrayWasmValue(ctx context.Context, v []string) (uint64, error) {
	return 0, nil
}

func (m *WasmModule) toObjectArrayWasmValue(ctx context.Context, v any) (uint64, error) {
	ret, err := m.malloc(ctx, 4+4) // GoSlice
	if err != nil {
		return 0, err
	}
	rv := reflect.ValueOf(v)
	if err := m.writeU32(ret, uint32(rv.Len())); err != nil {
		return 0, err
	}
	data, err := m.malloc(ctx, uint64(8*rv.Len()))
	if err != nil {
		return 0, err
	}
	if err := m.writeU32(ret+4, uint32(data)); err != nil {
		return 0, err
	}
	ptr := data
	for i := 0; i < rv.Len(); i++ {
		vv := rv.Index(i).Interface().(wasmStruct)
		if err := m.writeU32(ptr, uint32(vv.getPtr())); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

type Record struct {
	ptr uint64
}

func NewRecord(ctx context.Context) (*Record, error) {
	o, err := mod.newObject(ctx, "Record")
	if err != nil {
		return nil, err
	}
	return newRecord(o), nil
}

func newRecord(ptr uint64) *Record {
	if ptr == 0 {
		return nil
	}
	return &Record{ptr: ptr}
}

func (v *Record) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newRecordSlice(v []uint64) []*Record {
	ret := make([]*Record, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newRecord(vv))
	}
	return ret
}
func (v *Record) SetName(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Record_name", v.getPtr(), arg)
}

func (v *Record) GetName() string {
	ret, err := v.getName(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Record) getName(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Record_name", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Record) SetNext(_arg *Record) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Record_next", v.getPtr(), arg)
}

func (v *Record) GetNext() *Record {
	ret, err := v.getNext(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Record) getNext(ctx context.Context) (*Record, error) {
	var zero *Record
	p, err := mod.getField(ctx, "Record_next", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newRecord(p)
	return ret, nil
}

type Tag struct {
	ptr uint64
}

func NewTag(ctx context.Context) (*Tag, error) {
	o, err := mod.newObject(ctx, "Tag")
	if err != nil {
		return nil, err
	}
	return newTag(o), nil
}

func newTag(ptr uint64) *Tag {
	if ptr == 0 {
		return nil
	}
	return &Tag{ptr: ptr}
}

func (v *Tag) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newTagSlice(v []uint64) []*Tag {
	ret := make([]*Tag, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newTag(vv))
	}
	return ret
}
func (v *Tag) SetObjectType(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Tag_object_type", v.getPtr(), arg)
}

func (v *Tag) GetObjectType() uint32 {
	ret, err := v.getObjectType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Tag) getObjectType(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "Tag_object_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *Tag) SetMtflock(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Tag_mtflock", v.getPtr(), arg)
}

func (v *Tag) GetMtflock() uint32 {
	ret, err := v.getMtflock(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Tag) getMtflock(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "Tag_mtflock", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *Tag) SetAttrwf(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Tag_attrwf", v.getPtr(), arg)
}

func (v *Tag) GetAttrwf() uint32 {
	ret, err := v.getAttrwf(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Tag) getAttrwf(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "Tag_attrwf", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *Tag) SetSeq(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Tag_seq", v.getPtr(), arg)
}

func (v *Tag) GetSeq() uint32 {
	ret, err := v.getSeq(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Tag) getSeq(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "Tag_seq", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *Tag) SetId(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Tag_id", v.getPtr(), arg)
}

func (v *Tag) GetId() uint64 {
	ret, err := v.getId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Tag) getId(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "Tag_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

type Object struct {
	ptr uint64
}

func NewObject(ctx context.Context) (*Object, error) {
	o, err := mod.newObject(ctx, "Object")
	if err != nil {
		return nil, err
	}
	return newObject(o), nil
}

func newObject(ptr uint64) *Object {
	if ptr == 0 {
		return nil
	}
	return &Object{ptr: ptr}
}

func (v *Object) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newObjectSlice(v []uint64) []*Object {
	ret := make([]*Object, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newObject(vv))
	}
	return ret
}
func (v *Object) SetTag(_arg *Tag) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Object_tag", v.getPtr(), arg)
}

func (v *Object) GetTag() *Tag {
	ret, err := v.getTag(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Object) getTag(ctx context.Context) (*Tag, error) {
	var zero *Tag
	p, err := mod.getField(ctx, "Object_tag", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newTag(p)
	return ret, nil
}

func (v *Object) SetData(_arg *Record) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Object_data", v.getPtr(), arg)
}

func (v *Object) GetData() *Record {
	ret, err := v.getData(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Object) getData(ctx context.Context) (*Record, error) {
	var zero *Record
	p, err := mod.getField(ctx, "Object_data", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newRecord(p)
	return ret, nil
}

type SubNode struct {
	ptr uint64
}

func NewSubNode(ctx context.Context) (*SubNode, error) {
	o, err := mod.newObject(ctx, "SubNode")
	if err != nil {
		return nil, err
	}
	return newSubNode(o), nil
}

func newSubNode(ptr uint64) *SubNode {
	if ptr == 0 {
		return nil
	}
	return &SubNode{ptr: ptr}
}

func (v *SubNode) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newSubNodeSlice(v []uint64) []*SubNode {
	ret := make([]*SubNode, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newSubNode(vv))
	}
	return ret
}
func (v *SubNode) SetSeqLink(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "SubNode_seq_link", v.getPtr(), arg)
}

func (v *SubNode) GetSeqLink() *DictLink {
	ret, err := v.getSeqLink(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *SubNode) getSeqLink(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "SubNode_seq_link", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *SubNode) SetIdLink(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "SubNode_id_link", v.getPtr(), arg)
}

func (v *SubNode) GetIdLink() *DictLink {
	ret, err := v.getIdLink(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *SubNode) getIdLink(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "SubNode_id_link", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *SubNode) SetNode(_arg *Node) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "SubNode_node", v.getPtr(), arg)
}

func (v *SubNode) GetNode() *Node {
	ret, err := v.getNode(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *SubNode) getNode(ctx context.Context) (*Node, error) {
	var zero *Node
	p, err := mod.getField(ctx, "SubNode_node", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newNode(p)
	return ret, nil
}

func (v *SubNode) SetInId(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "SubNode_in_id", v.getPtr(), arg)
}

func (v *SubNode) GetInId() *DictLink {
	ret, err := v.getInId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *SubNode) getInId(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "SubNode_in_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *SubNode) SetOutId(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "SubNode_out_id", v.getPtr(), arg)
}

func (v *SubNode) GetOutId() *DictLink {
	ret, err := v.getOutId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *SubNode) getOutId(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "SubNode_out_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *SubNode) SetInSeq(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "SubNode_in_seq", v.getPtr(), arg)
}

func (v *SubNode) GetInSeq() *DictLink {
	ret, err := v.getInSeq(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *SubNode) getInSeq(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "SubNode_in_seq", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *SubNode) SetOutSeq(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "SubNode_out_seq", v.getPtr(), arg)
}

func (v *SubNode) GetOutSeq() *DictLink {
	ret, err := v.getOutSeq(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *SubNode) getOutSeq(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "SubNode_out_seq", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

type Node struct {
	ptr uint64
}

func NewNode(ctx context.Context) (*Node, error) {
	o, err := mod.newObject(ctx, "Node")
	if err != nil {
		return nil, err
	}
	return newNode(o), nil
}

func newNode(ptr uint64) *Node {
	if ptr == 0 {
		return nil
	}
	return &Node{ptr: ptr}
}

func (v *Node) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newNodeSlice(v []uint64) []*Node {
	ret := make([]*Node, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newNode(vv))
	}
	return ret
}
func (v *Node) SetBase(_arg *Object) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Node_base", v.getPtr(), arg)
}

func (v *Node) GetBase() *Object {
	ret, err := v.getBase(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Node) getBase(ctx context.Context) (*Object, error) {
	var zero *Object
	p, err := mod.getField(ctx, "Node_base", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newObject(p)
	return ret, nil
}

func (v *Node) SetRoot(_arg *Graph) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Node_root", v.getPtr(), arg)
}

func (v *Node) GetRoot() *Graph {
	ret, err := v.getRoot(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Node) getRoot(ctx context.Context) (*Graph, error) {
	var zero *Graph
	p, err := mod.getField(ctx, "Node_root", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *Node) SetMainsub(_arg *SubNode) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Node_mainsub", v.getPtr(), arg)
}

func (v *Node) GetMainsub() *SubNode {
	ret, err := v.getMainsub(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Node) getMainsub(ctx context.Context) (*SubNode, error) {
	var zero *SubNode
	p, err := mod.getField(ctx, "Node_mainsub", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newSubNode(p)
	return ret, nil
}

type Edge struct {
	ptr uint64
}

func NewEdge(ctx context.Context) (*Edge, error) {
	o, err := mod.newObject(ctx, "Edge")
	if err != nil {
		return nil, err
	}
	return newEdge(o), nil
}

func newEdge(ptr uint64) *Edge {
	if ptr == 0 {
		return nil
	}
	return &Edge{ptr: ptr}
}

func (v *Edge) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newEdgeSlice(v []uint64) []*Edge {
	ret := make([]*Edge, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newEdge(vv))
	}
	return ret
}
func (v *Edge) SetBase(_arg *Object) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Edge_base", v.getPtr(), arg)
}

func (v *Edge) GetBase() *Object {
	ret, err := v.getBase(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Edge) getBase(ctx context.Context) (*Object, error) {
	var zero *Object
	p, err := mod.getField(ctx, "Edge_base", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newObject(p)
	return ret, nil
}

func (v *Edge) SetIdLink(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Edge_id_link", v.getPtr(), arg)
}

func (v *Edge) GetIdLink() *DictLink {
	ret, err := v.getIdLink(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Edge) getIdLink(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "Edge_id_link", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *Edge) SetSeqLink(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Edge_seq_link", v.getPtr(), arg)
}

func (v *Edge) GetSeqLink() *DictLink {
	ret, err := v.getSeqLink(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Edge) getSeqLink(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "Edge_seq_link", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *Edge) SetNode(_arg *Node) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Edge_node", v.getPtr(), arg)
}

func (v *Edge) GetNode() *Node {
	ret, err := v.getNode(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Edge) getNode(ctx context.Context) (*Node, error) {
	var zero *Node
	p, err := mod.getField(ctx, "Edge_node", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newNode(p)
	return ret, nil
}

type EdgePair struct {
	ptr uint64
}

func NewEdgePair(ctx context.Context) (*EdgePair, error) {
	o, err := mod.newObject(ctx, "EdgePair")
	if err != nil {
		return nil, err
	}
	return newEdgePair(o), nil
}

func newEdgePair(ptr uint64) *EdgePair {
	if ptr == 0 {
		return nil
	}
	return &EdgePair{ptr: ptr}
}

func (v *EdgePair) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newEdgePairSlice(v []uint64) []*EdgePair {
	ret := make([]*EdgePair, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newEdgePair(vv))
	}
	return ret
}
func (v *EdgePair) SetOut(_arg *Edge) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "EdgePair_out", v.getPtr(), arg)
}

func (v *EdgePair) GetOut() *Edge {
	ret, err := v.getOut(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *EdgePair) getOut(ctx context.Context) (*Edge, error) {
	var zero *Edge
	p, err := mod.getField(ctx, "EdgePair_out", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

func (v *EdgePair) SetIn(_arg *Edge) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "EdgePair_in", v.getPtr(), arg)
}

func (v *EdgePair) GetIn() *Edge {
	ret, err := v.getIn(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *EdgePair) getIn(ctx context.Context) (*Edge, error) {
	var zero *Edge
	p, err := mod.getField(ctx, "EdgePair_in", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

type GraphDescriptor struct {
	ptr uint64
}

func NewGraphDescriptor(ctx context.Context) (*GraphDescriptor, error) {
	o, err := mod.newObject(ctx, "GraphDescriptor")
	if err != nil {
		return nil, err
	}
	return newGraphDescriptor(o), nil
}

func newGraphDescriptor(ptr uint64) *GraphDescriptor {
	if ptr == 0 {
		return nil
	}
	return &GraphDescriptor{ptr: ptr}
}

func (v *GraphDescriptor) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newGraphDescriptorSlice(v []uint64) []*GraphDescriptor {
	ret := make([]*GraphDescriptor, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newGraphDescriptor(vv))
	}
	return ret
}
func (v *GraphDescriptor) SetDirected(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "GraphDescriptor_directed", v.getPtr(), arg)
}

func (v *GraphDescriptor) GetDirected() uint32 {
	ret, err := v.getDirected(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *GraphDescriptor) getDirected(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "GraphDescriptor_directed", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *GraphDescriptor) SetStrict(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "GraphDescriptor_strict", v.getPtr(), arg)
}

func (v *GraphDescriptor) GetStrict() uint32 {
	ret, err := v.getStrict(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *GraphDescriptor) getStrict(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "GraphDescriptor_strict", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *GraphDescriptor) SetNoLoop(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "GraphDescriptor_no_loop", v.getPtr(), arg)
}

func (v *GraphDescriptor) GetNoLoop() uint32 {
	ret, err := v.getNoLoop(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *GraphDescriptor) getNoLoop(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "GraphDescriptor_no_loop", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *GraphDescriptor) SetMaingraph(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "GraphDescriptor_maingraph", v.getPtr(), arg)
}

func (v *GraphDescriptor) GetMaingraph() uint32 {
	ret, err := v.getMaingraph(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *GraphDescriptor) getMaingraph(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "GraphDescriptor_maingraph", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *GraphDescriptor) SetNoWrite(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "GraphDescriptor_no_write", v.getPtr(), arg)
}

func (v *GraphDescriptor) GetNoWrite() uint32 {
	ret, err := v.getNoWrite(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *GraphDescriptor) getNoWrite(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "GraphDescriptor_no_write", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *GraphDescriptor) SetHasAttrs(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "GraphDescriptor_has_attrs", v.getPtr(), arg)
}

func (v *GraphDescriptor) GetHasAttrs() uint32 {
	ret, err := v.getHasAttrs(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *GraphDescriptor) getHasAttrs(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "GraphDescriptor_has_attrs", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *GraphDescriptor) SetHasCmpnd(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "GraphDescriptor_has_cmpnd", v.getPtr(), arg)
}

func (v *GraphDescriptor) GetHasCmpnd() uint32 {
	ret, err := v.getHasCmpnd(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *GraphDescriptor) getHasCmpnd(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "GraphDescriptor_has_cmpnd", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

type IDAllocator struct {
	ptr uint64
}

func NewIDAllocator(ctx context.Context) (*IDAllocator, error) {
	o, err := mod.newObject(ctx, "IDAllocator")
	if err != nil {
		return nil, err
	}
	return newIDAllocator(o), nil
}

func newIDAllocator(ptr uint64) *IDAllocator {
	if ptr == 0 {
		return nil
	}
	return &IDAllocator{ptr: ptr}
}

func (v *IDAllocator) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newIDAllocatorSlice(v []uint64) []*IDAllocator {
	ret := make([]*IDAllocator, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newIDAllocator(vv))
	}
	return ret
}
func (v *IDAllocator) SetOpen(ctx context.Context, arg *CallbackFunc[func(context.Context, *Graph, *ClientDiscipline) (any, error)]) error {
	if mod.lookupFuncMap.IDAllocator_Open == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_IDAllocator_Open before")
	}
	mod.callbackFuncMap.IDAllocator_Open[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "IDAllocator_open", v.getPtr())
}

func (v *IDAllocator) SetMap(ctx context.Context, arg *CallbackFunc[func(context.Context, any, int, string, *uint64, int) (int32, error)]) error {
	if mod.lookupFuncMap.IDAllocator_Map == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_IDAllocator_Map before")
	}
	mod.callbackFuncMap.IDAllocator_Map[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "IDAllocator_map", v.getPtr())
}

func (v *IDAllocator) SetAlloc(ctx context.Context, arg *CallbackFunc[func(context.Context, any, int, uint64) (int32, error)]) error {
	if mod.lookupFuncMap.IDAllocator_Alloc == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_IDAllocator_Alloc before")
	}
	mod.callbackFuncMap.IDAllocator_Alloc[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "IDAllocator_alloc", v.getPtr())
}

func (v *IDAllocator) SetFree(ctx context.Context, arg *CallbackFunc[func(context.Context, any, int, uint64) error]) error {
	if mod.lookupFuncMap.IDAllocator_Free == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_IDAllocator_Free before")
	}
	mod.callbackFuncMap.IDAllocator_Free[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "IDAllocator_free", v.getPtr())
}

func (v *IDAllocator) SetPrint(ctx context.Context, arg *CallbackFunc[func(context.Context, any, int, uint64) (string, error)]) error {
	if mod.lookupFuncMap.IDAllocator_Print == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_IDAllocator_Print before")
	}
	mod.callbackFuncMap.IDAllocator_Print[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "IDAllocator_print", v.getPtr())
}

func (v *IDAllocator) SetClose(ctx context.Context, arg *CallbackFunc[func(context.Context, any) error]) error {
	if mod.lookupFuncMap.IDAllocator_Close == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_IDAllocator_Close before")
	}
	mod.callbackFuncMap.IDAllocator_Close[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "IDAllocator_close", v.getPtr())
}

func (v *IDAllocator) SetIdregister(ctx context.Context, arg *CallbackFunc[func(context.Context, any, int, any) error]) error {
	if mod.lookupFuncMap.IDAllocator_IdRegister == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_IDAllocator_IdRegister before")
	}
	mod.callbackFuncMap.IDAllocator_IdRegister[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "IDAllocator_idregister", v.getPtr())
}

type IOService struct {
	ptr uint64
}

func NewIOService(ctx context.Context) (*IOService, error) {
	o, err := mod.newObject(ctx, "IOService")
	if err != nil {
		return nil, err
	}
	return newIOService(o), nil
}

func newIOService(ptr uint64) *IOService {
	if ptr == 0 {
		return nil
	}
	return &IOService{ptr: ptr}
}

func (v *IOService) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newIOServiceSlice(v []uint64) []*IOService {
	ret := make([]*IOService, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newIOService(vv))
	}
	return ret
}
func (v *IOService) SetAfread(ctx context.Context, arg *CallbackFunc[func(context.Context, any, string, int) (int, error)]) error {
	if mod.lookupFuncMap.IOService_Afread == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_IOService_Afread before")
	}
	mod.callbackFuncMap.IOService_Afread[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "IOService_afread", v.getPtr())
}

func (v *IOService) SetPutstr(ctx context.Context, arg *CallbackFunc[func(context.Context, any, string) (int, error)]) error {
	if mod.lookupFuncMap.IOService_Putstr == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_IOService_Putstr before")
	}
	mod.callbackFuncMap.IOService_Putstr[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "IOService_putstr", v.getPtr())
}

func (v *IOService) SetFlush(ctx context.Context, arg *CallbackFunc[func(context.Context, any) (int, error)]) error {
	if mod.lookupFuncMap.IOService_Flush == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_IOService_Flush before")
	}
	mod.callbackFuncMap.IOService_Flush[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "IOService_flush", v.getPtr())
}

type ClientDiscipline struct {
	ptr uint64
}

func NewClientDiscipline(ctx context.Context) (*ClientDiscipline, error) {
	o, err := mod.newObject(ctx, "ClientDiscipline")
	if err != nil {
		return nil, err
	}
	return newClientDiscipline(o), nil
}

func newClientDiscipline(ptr uint64) *ClientDiscipline {
	if ptr == 0 {
		return nil
	}
	return &ClientDiscipline{ptr: ptr}
}

func (v *ClientDiscipline) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newClientDisciplineSlice(v []uint64) []*ClientDiscipline {
	ret := make([]*ClientDiscipline, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newClientDiscipline(vv))
	}
	return ret
}
func (v *ClientDiscipline) SetId(_arg *IDAllocator) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ClientDiscipline_id", v.getPtr(), arg)
}

func (v *ClientDiscipline) GetId() *IDAllocator {
	ret, err := v.getId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ClientDiscipline) getId(ctx context.Context) (*IDAllocator, error) {
	var zero *IDAllocator
	p, err := mod.getField(ctx, "ClientDiscipline_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newIDAllocator(p)
	return ret, nil
}

func (v *ClientDiscipline) SetIo(_arg *IOService) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ClientDiscipline_io", v.getPtr(), arg)
}

func (v *ClientDiscipline) GetIo() *IOService {
	ret, err := v.getIo(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ClientDiscipline) getIo(ctx context.Context) (*IOService, error) {
	var zero *IOService
	p, err := mod.getField(ctx, "ClientDiscipline_io", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newIOService(p)
	return ret, nil
}

type State struct {
	ptr uint64
}

func NewState(ctx context.Context) (*State, error) {
	o, err := mod.newObject(ctx, "State")
	if err != nil {
		return nil, err
	}
	return newState(o), nil
}

func newState(ptr uint64) *State {
	if ptr == 0 {
		return nil
	}
	return &State{ptr: ptr}
}

func (v *State) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newStateSlice(v []uint64) []*State {
	ret := make([]*State, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newState(vv))
	}
	return ret
}
func (v *State) SetId(_arg any) error {
	ctx := context.Background()
	arg, err := mod.toAnyWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "State_id", v.getPtr(), arg)
}

func (v *State) GetId() any {
	ret, err := v.getId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *State) getId(ctx context.Context) (any, error) {
	var zero any
	p, err := mod.getField(ctx, "State_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

type ClientEventCallback struct {
	ptr uint64
}

func NewClientEventCallback(ctx context.Context) (*ClientEventCallback, error) {
	o, err := mod.newObject(ctx, "ClientEventCallback")
	if err != nil {
		return nil, err
	}
	return newClientEventCallback(o), nil
}

func newClientEventCallback(ptr uint64) *ClientEventCallback {
	if ptr == 0 {
		return nil
	}
	return &ClientEventCallback{ptr: ptr}
}

func (v *ClientEventCallback) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newClientEventCallbackSlice(v []uint64) []*ClientEventCallback {
	ret := make([]*ClientEventCallback, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newClientEventCallback(vv))
	}
	return ret
}

type CallbackStack struct {
	ptr uint64
}

func NewCallbackStack(ctx context.Context) (*CallbackStack, error) {
	o, err := mod.newObject(ctx, "CallbackStack")
	if err != nil {
		return nil, err
	}
	return newCallbackStack(o), nil
}

func newCallbackStack(ptr uint64) *CallbackStack {
	if ptr == 0 {
		return nil
	}
	return &CallbackStack{ptr: ptr}
}

func (v *CallbackStack) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newCallbackStackSlice(v []uint64) []*CallbackStack {
	ret := make([]*CallbackStack, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newCallbackStack(vv))
	}
	return ret
}
func (v *CallbackStack) SetF(_arg *ClientEventCallback) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "CallbackStack_f", v.getPtr(), arg)
}

func (v *CallbackStack) GetF() *ClientEventCallback {
	ret, err := v.getF(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *CallbackStack) getF(ctx context.Context) (*ClientEventCallback, error) {
	var zero *ClientEventCallback
	p, err := mod.getField(ctx, "CallbackStack_f", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newClientEventCallback(p)
	return ret, nil
}

func (v *CallbackStack) SetState(_arg any) error {
	ctx := context.Background()
	arg, err := mod.toAnyWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "CallbackStack_state", v.getPtr(), arg)
}

func (v *CallbackStack) GetState() any {
	ret, err := v.getState(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *CallbackStack) getState(ctx context.Context) (any, error) {
	var zero any
	p, err := mod.getField(ctx, "CallbackStack_state", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

func (v *CallbackStack) SetPrev(_arg *CallbackStack) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "CallbackStack_prev", v.getPtr(), arg)
}

func (v *CallbackStack) GetPrev() *CallbackStack {
	ret, err := v.getPrev(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *CallbackStack) getPrev(ctx context.Context) (*CallbackStack, error) {
	var zero *CallbackStack
	p, err := mod.getField(ctx, "CallbackStack_prev", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newCallbackStack(p)
	return ret, nil
}

type CommonFields struct {
	ptr uint64
}

func NewCommonFields(ctx context.Context) (*CommonFields, error) {
	o, err := mod.newObject(ctx, "CommonFields")
	if err != nil {
		return nil, err
	}
	return newCommonFields(o), nil
}

func newCommonFields(ptr uint64) *CommonFields {
	if ptr == 0 {
		return nil
	}
	return &CommonFields{ptr: ptr}
}

func (v *CommonFields) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newCommonFieldsSlice(v []uint64) []*CommonFields {
	ret := make([]*CommonFields, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newCommonFields(vv))
	}
	return ret
}
func (v *CommonFields) SetDisc(_arg *ClientDiscipline) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "CommonFields_disc", v.getPtr(), arg)
}

func (v *CommonFields) GetDisc() *ClientDiscipline {
	ret, err := v.getDisc(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *CommonFields) getDisc(ctx context.Context) (*ClientDiscipline, error) {
	var zero *ClientDiscipline
	p, err := mod.getField(ctx, "CommonFields_disc", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newClientDiscipline(p)
	return ret, nil
}

func (v *CommonFields) SetState(_arg *State) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "CommonFields_state", v.getPtr(), arg)
}

func (v *CommonFields) GetState() *State {
	ret, err := v.getState(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *CommonFields) getState(ctx context.Context) (*State, error) {
	var zero *State
	p, err := mod.getField(ctx, "CommonFields_state", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newState(p)
	return ret, nil
}

func (v *CommonFields) SetStrdict(_arg *Dict) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "CommonFields_strdict", v.getPtr(), arg)
}

func (v *CommonFields) GetStrdict() *Dict {
	ret, err := v.getStrdict(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *CommonFields) getStrdict(ctx context.Context) (*Dict, error) {
	var zero *Dict
	p, err := mod.getField(ctx, "CommonFields_strdict", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDict(p)
	return ret, nil
}

func (v *CommonFields) SetSeq(_arg []uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64ArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "CommonFields_seq", v.getPtr(), arg)
}

func (v *CommonFields) GetSeq() []uint64 {
	ret, err := v.getSeq(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *CommonFields) getSeq(ctx context.Context) ([]uint64, error) {
	var zero []uint64
	p, err := mod.getField(ctx, "CommonFields_seq", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64Slice(slice)
	return ret, nil
}

func (v *CommonFields) SetCb(_arg *CallbackStack) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "CommonFields_cb", v.getPtr(), arg)
}

func (v *CommonFields) GetCb() *CallbackStack {
	ret, err := v.getCb(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *CommonFields) getCb(ctx context.Context) (*CallbackStack, error) {
	var zero *CallbackStack
	p, err := mod.getField(ctx, "CommonFields_cb", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newCallbackStack(p)
	return ret, nil
}

func (v *CommonFields) SetLookupByName(_arg []*Dict) error {
	ctx := context.Background()
	arg, err := mod.toObjectArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "CommonFields_lookup_by_name", v.getPtr(), arg)
}

func (v *CommonFields) GetLookupByName() []*Dict {
	ret, err := v.getLookupByName(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *CommonFields) getLookupByName(ctx context.Context) ([]*Dict, error) {
	var zero []*Dict
	p, err := mod.getField(ctx, "CommonFields_lookup_by_name", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := newDictSlice(slice)
	return ret, nil
}

func (v *CommonFields) SetLookupById(_arg []*Dict) error {
	ctx := context.Background()
	arg, err := mod.toObjectArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "CommonFields_lookup_by_id", v.getPtr(), arg)
}

func (v *CommonFields) GetLookupById() []*Dict {
	ret, err := v.getLookupById(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *CommonFields) getLookupById(ctx context.Context) ([]*Dict, error) {
	var zero []*Dict
	p, err := mod.getField(ctx, "CommonFields_lookup_by_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := newDictSlice(slice)
	return ret, nil
}

type Graph struct {
	ptr uint64
}

func NewGraph(ctx context.Context) (*Graph, error) {
	o, err := mod.newObject(ctx, "Graph")
	if err != nil {
		return nil, err
	}
	return newGraph(o), nil
}

func newGraph(ptr uint64) *Graph {
	if ptr == 0 {
		return nil
	}
	return &Graph{ptr: ptr}
}

func (v *Graph) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newGraphSlice(v []uint64) []*Graph {
	ret := make([]*Graph, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newGraph(vv))
	}
	return ret
}
func (v *Graph) SetBase(_arg *Object) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_base", v.getPtr(), arg)
}

func (v *Graph) GetBase() *Object {
	ret, err := v.getBase(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getBase(ctx context.Context) (*Object, error) {
	var zero *Object
	p, err := mod.getField(ctx, "Graph_base", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newObject(p)
	return ret, nil
}

func (v *Graph) SetDesc(_arg *GraphDescriptor) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_desc", v.getPtr(), arg)
}

func (v *Graph) GetDesc() *GraphDescriptor {
	ret, err := v.getDesc(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getDesc(ctx context.Context) (*GraphDescriptor, error) {
	var zero *GraphDescriptor
	p, err := mod.getField(ctx, "Graph_desc", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newGraphDescriptor(p)
	return ret, nil
}

func (v *Graph) SetSeqLink(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_seq_link", v.getPtr(), arg)
}

func (v *Graph) GetSeqLink() *DictLink {
	ret, err := v.getSeqLink(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getSeqLink(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "Graph_seq_link", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *Graph) SetIdLink(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_id_link", v.getPtr(), arg)
}

func (v *Graph) GetIdLink() *DictLink {
	ret, err := v.getIdLink(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getIdLink(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "Graph_id_link", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *Graph) SetNSeq(_arg *Dict) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_n_seq", v.getPtr(), arg)
}

func (v *Graph) GetNSeq() *Dict {
	ret, err := v.getNSeq(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getNSeq(ctx context.Context) (*Dict, error) {
	var zero *Dict
	p, err := mod.getField(ctx, "Graph_n_seq", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDict(p)
	return ret, nil
}

func (v *Graph) SetESeq(_arg *Dict) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_e_seq", v.getPtr(), arg)
}

func (v *Graph) GetESeq() *Dict {
	ret, err := v.getESeq(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getESeq(ctx context.Context) (*Dict, error) {
	var zero *Dict
	p, err := mod.getField(ctx, "Graph_e_seq", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDict(p)
	return ret, nil
}

func (v *Graph) SetEId(_arg *Dict) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_e_id", v.getPtr(), arg)
}

func (v *Graph) GetEId() *Dict {
	ret, err := v.getEId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getEId(ctx context.Context) (*Dict, error) {
	var zero *Dict
	p, err := mod.getField(ctx, "Graph_e_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDict(p)
	return ret, nil
}

func (v *Graph) SetGSeq(_arg *Dict) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_g_seq", v.getPtr(), arg)
}

func (v *Graph) GetGSeq() *Dict {
	ret, err := v.getGSeq(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getGSeq(ctx context.Context) (*Dict, error) {
	var zero *Dict
	p, err := mod.getField(ctx, "Graph_g_seq", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDict(p)
	return ret, nil
}

func (v *Graph) SetGId(_arg *Dict) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_g_id", v.getPtr(), arg)
}

func (v *Graph) GetGId() *Dict {
	ret, err := v.getGId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getGId(ctx context.Context) (*Dict, error) {
	var zero *Dict
	p, err := mod.getField(ctx, "Graph_g_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDict(p)
	return ret, nil
}

func (v *Graph) SetParent(_arg *Graph) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_parent", v.getPtr(), arg)
}

func (v *Graph) GetParent() *Graph {
	ret, err := v.getParent(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getParent(ctx context.Context) (*Graph, error) {
	var zero *Graph
	p, err := mod.getField(ctx, "Graph_parent", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *Graph) SetRoot(_arg *Graph) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_root", v.getPtr(), arg)
}

func (v *Graph) GetRoot() *Graph {
	ret, err := v.getRoot(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getRoot(ctx context.Context) (*Graph, error) {
	var zero *Graph
	p, err := mod.getField(ctx, "Graph_root", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *Graph) SetClos(_arg *CommonFields) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Graph_clos", v.getPtr(), arg)
}

func (v *Graph) GetClos() *CommonFields {
	ret, err := v.getClos(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Graph) getClos(ctx context.Context) (*CommonFields, error) {
	var zero *CommonFields
	p, err := mod.getField(ctx, "Graph_clos", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newCommonFields(p)
	return ret, nil
}

type Attr struct {
	ptr uint64
}

func NewAttr(ctx context.Context) (*Attr, error) {
	o, err := mod.newObject(ctx, "Attr")
	if err != nil {
		return nil, err
	}
	return newAttr(o), nil
}

func newAttr(ptr uint64) *Attr {
	if ptr == 0 {
		return nil
	}
	return &Attr{ptr: ptr}
}

func (v *Attr) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newAttrSlice(v []uint64) []*Attr {
	ret := make([]*Attr, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newAttr(vv))
	}
	return ret
}
func (v *Attr) SetH(_arg *Record) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Attr_h", v.getPtr(), arg)
}

func (v *Attr) GetH() *Record {
	ret, err := v.getH(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Attr) getH(ctx context.Context) (*Record, error) {
	var zero *Record
	p, err := mod.getField(ctx, "Attr_h", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newRecord(p)
	return ret, nil
}

func (v *Attr) SetDict(_arg *Dict) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Attr_dict", v.getPtr(), arg)
}

func (v *Attr) GetDict() *Dict {
	ret, err := v.getDict(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Attr) getDict(ctx context.Context) (*Dict, error) {
	var zero *Dict
	p, err := mod.getField(ctx, "Attr_dict", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDict(p)
	return ret, nil
}

func (v *Attr) SetStr(_arg []string) error {
	ctx := context.Background()
	arg, err := mod.toStringArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Attr_str", v.getPtr(), arg)
}

func (v *Attr) GetStr() []string {
	ret, err := v.getStr(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Attr) getStr(ctx context.Context) ([]string, error) {
	var zero []string
	p, err := mod.getField(ctx, "Attr_str", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toStringSlice(ctx, slice)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

type Sym struct {
	ptr uint64
}

func NewSym(ctx context.Context) (*Sym, error) {
	o, err := mod.newObject(ctx, "Sym")
	if err != nil {
		return nil, err
	}
	return newSym(o), nil
}

func newSym(ptr uint64) *Sym {
	if ptr == 0 {
		return nil
	}
	return &Sym{ptr: ptr}
}

func (v *Sym) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newSymSlice(v []uint64) []*Sym {
	ret := make([]*Sym, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newSym(vv))
	}
	return ret
}
func (v *Sym) SetLink(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Sym_link", v.getPtr(), arg)
}

func (v *Sym) GetLink() *DictLink {
	ret, err := v.getLink(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Sym) getLink(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "Sym_link", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *Sym) SetName(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Sym_name", v.getPtr(), arg)
}

func (v *Sym) GetName() string {
	ret, err := v.getName(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Sym) getName(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Sym_name", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Sym) SetDefval(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Sym_defval", v.getPtr(), arg)
}

func (v *Sym) GetDefval() string {
	ret, err := v.getDefval(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Sym) getDefval(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Sym_defval", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Sym) SetId(_arg int32) error {
	ctx := context.Background()
	arg, err := mod.toInt32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Sym_id", v.getPtr(), arg)
}

func (v *Sym) GetId() int32 {
	ret, err := v.getId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Sym) getId(ctx context.Context) (int32, error) {
	var zero int32
	p, err := mod.getField(ctx, "Sym_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt32(p)
	return ret, nil
}

func (v *Sym) SetKind(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Sym_kind", v.getPtr(), arg)
}

func (v *Sym) GetKind() uint32 {
	ret, err := v.getKind(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Sym) getKind(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "Sym_kind", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *Sym) SetFixed(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Sym_fixed", v.getPtr(), arg)
}

func (v *Sym) GetFixed() uint32 {
	ret, err := v.getFixed(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Sym) getFixed(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "Sym_fixed", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *Sym) SetPrint(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Sym_print", v.getPtr(), arg)
}

func (v *Sym) GetPrint() uint32 {
	ret, err := v.getPrint(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Sym) getPrint(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "Sym_print", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

type DataDict struct {
	ptr uint64
}

func NewDataDict(ctx context.Context) (*DataDict, error) {
	o, err := mod.newObject(ctx, "DataDict")
	if err != nil {
		return nil, err
	}
	return newDataDict(o), nil
}

func newDataDict(ptr uint64) *DataDict {
	if ptr == 0 {
		return nil
	}
	return &DataDict{ptr: ptr}
}

func (v *DataDict) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newDataDictSlice(v []uint64) []*DataDict {
	ret := make([]*DataDict, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newDataDict(vv))
	}
	return ret
}
func (v *DataDict) SetH(_arg *Record) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DataDict_h", v.getPtr(), arg)
}

func (v *DataDict) GetH() *Record {
	ret, err := v.getH(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DataDict) getH(ctx context.Context) (*Record, error) {
	var zero *Record
	p, err := mod.getField(ctx, "DataDict_h", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newRecord(p)
	return ret, nil
}

type DictLink struct {
	ptr uint64
}

func NewDictLink(ctx context.Context) (*DictLink, error) {
	o, err := mod.newObject(ctx, "DictLink")
	if err != nil {
		return nil, err
	}
	return newDictLink(o), nil
}

func newDictLink(ptr uint64) *DictLink {
	if ptr == 0 {
		return nil
	}
	return &DictLink{ptr: ptr}
}

func (v *DictLink) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newDictLinkSlice(v []uint64) []*DictLink {
	ret := make([]*DictLink, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newDictLink(vv))
	}
	return ret
}
func (v *DictLink) SetRight(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictLink_right", v.getPtr(), arg)
}

func (v *DictLink) GetRight() *DictLink {
	ret, err := v.getRight(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictLink) getRight(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "DictLink_right", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *DictLink) SetHash(_arg uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictLink_hash", v.getPtr(), arg)
}

func (v *DictLink) GetHash() uint32 {
	ret, err := v.getHash(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictLink) getHash(ctx context.Context) (uint32, error) {
	var zero uint32
	p, err := mod.getField(ctx, "DictLink_hash", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32(p)
	return ret, nil
}

func (v *DictLink) SetLeft(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictLink_left", v.getPtr(), arg)
}

func (v *DictLink) GetLeft() *DictLink {
	ret, err := v.getLeft(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictLink) getLeft(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "DictLink_left", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

type DictHold struct {
	ptr uint64
}

func NewDictHold(ctx context.Context) (*DictHold, error) {
	o, err := mod.newObject(ctx, "DictHold")
	if err != nil {
		return nil, err
	}
	return newDictHold(o), nil
}

func newDictHold(ptr uint64) *DictHold {
	if ptr == 0 {
		return nil
	}
	return &DictHold{ptr: ptr}
}

func (v *DictHold) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newDictHoldSlice(v []uint64) []*DictHold {
	ret := make([]*DictHold, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newDictHold(vv))
	}
	return ret
}
func (v *DictHold) SetHdr(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictHold_hdr", v.getPtr(), arg)
}

func (v *DictHold) GetHdr() *DictLink {
	ret, err := v.getHdr(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictHold) getHdr(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "DictHold_hdr", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *DictHold) SetObj(_arg any) error {
	ctx := context.Background()
	arg, err := mod.toAnyWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictHold_obj", v.getPtr(), arg)
}

func (v *DictHold) GetObj() any {
	ret, err := v.getObj(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictHold) getObj(ctx context.Context) (any, error) {
	var zero any
	p, err := mod.getField(ctx, "DictHold_obj", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

type DictMethod struct {
	ptr uint64
}

func NewDictMethod(ctx context.Context) (*DictMethod, error) {
	o, err := mod.newObject(ctx, "DictMethod")
	if err != nil {
		return nil, err
	}
	return newDictMethod(o), nil
}

func newDictMethod(ptr uint64) *DictMethod {
	if ptr == 0 {
		return nil
	}
	return &DictMethod{ptr: ptr}
}

func (v *DictMethod) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newDictMethodSlice(v []uint64) []*DictMethod {
	ret := make([]*DictMethod, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newDictMethod(vv))
	}
	return ret
}
func (v *DictMethod) SetSearchf(ctx context.Context, arg *CallbackFunc[func(context.Context, *Dict, any, int) (any, error)]) error {
	if mod.lookupFuncMap.DictSearch == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DictSearch before")
	}
	mod.callbackFuncMap.DictSearch[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DictMethod_searchf", v.getPtr())
}

func (v *DictMethod) SetType(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictMethod_type", v.getPtr(), arg)
}

func (v *DictMethod) GetType() int64 {
	ret, err := v.getType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictMethod) getType(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "DictMethod_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

type DictData struct {
	ptr uint64
}

func NewDictData(ctx context.Context) (*DictData, error) {
	o, err := mod.newObject(ctx, "DictData")
	if err != nil {
		return nil, err
	}
	return newDictData(o), nil
}

func newDictData(ptr uint64) *DictData {
	if ptr == 0 {
		return nil
	}
	return &DictData{ptr: ptr}
}

func (v *DictData) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newDictDataSlice(v []uint64) []*DictData {
	ret := make([]*DictData, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newDictData(vv))
	}
	return ret
}
func (v *DictData) SetType(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictData_type", v.getPtr(), arg)
}

func (v *DictData) GetType() int64 {
	ret, err := v.getType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictData) getType(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "DictData_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *DictData) SetHere(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictData_here", v.getPtr(), arg)
}

func (v *DictData) GetHere() *DictLink {
	ret, err := v.getHere(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictData) getHere(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "DictData_here", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *DictData) SetHtab(_arg []*DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictData_htab", v.getPtr(), arg)
}

func (v *DictData) GetHtab() []*DictLink {
	ret, err := v.getHtab(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictData) getHtab(ctx context.Context) ([]*DictLink, error) {
	var zero []*DictLink
	p, err := mod.getField(ctx, "DictData_htab", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := newDictLinkSlice(slice)
	return ret, nil
}

func (v *DictData) SetHead(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictData_head", v.getPtr(), arg)
}

func (v *DictData) GetHead() *DictLink {
	ret, err := v.getHead(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictData) getHead(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "DictData_head", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *DictData) SetNtab(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictData_ntab", v.getPtr(), arg)
}

func (v *DictData) GetNtab() int64 {
	ret, err := v.getNtab(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictData) getNtab(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "DictData_ntab", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *DictData) SetSize(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictData_size", v.getPtr(), arg)
}

func (v *DictData) GetSize() int64 {
	ret, err := v.getSize(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictData) getSize(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "DictData_size", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *DictData) SetLoop(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictData_loop", v.getPtr(), arg)
}

func (v *DictData) GetLoop() int64 {
	ret, err := v.getLoop(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictData) getLoop(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "DictData_loop", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

type DictDisc struct {
	ptr uint64
}

func NewDictDisc(ctx context.Context) (*DictDisc, error) {
	o, err := mod.newObject(ctx, "DictDisc")
	if err != nil {
		return nil, err
	}
	return newDictDisc(o), nil
}

func newDictDisc(ptr uint64) *DictDisc {
	if ptr == 0 {
		return nil
	}
	return &DictDisc{ptr: ptr}
}

func (v *DictDisc) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newDictDiscSlice(v []uint64) []*DictDisc {
	ret := make([]*DictDisc, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newDictDisc(vv))
	}
	return ret
}
func (v *DictDisc) SetKey(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictDisc_key", v.getPtr(), arg)
}

func (v *DictDisc) GetKey() int64 {
	ret, err := v.getKey(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictDisc) getKey(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "DictDisc_key", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *DictDisc) SetSize(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictDisc_size", v.getPtr(), arg)
}

func (v *DictDisc) GetSize() int64 {
	ret, err := v.getSize(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictDisc) getSize(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "DictDisc_size", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *DictDisc) SetLink(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictDisc_link", v.getPtr(), arg)
}

func (v *DictDisc) GetLink() int64 {
	ret, err := v.getLink(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictDisc) getLink(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "DictDisc_link", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *DictDisc) SetMakef(ctx context.Context, arg *CallbackFunc[func(context.Context, any, *DictDisc) (any, error)]) error {
	if mod.lookupFuncMap.DictMake == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DictMake before")
	}
	mod.callbackFuncMap.DictMake[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DictDisc_makef", v.getPtr())
}

func (v *DictDisc) SetFreef(ctx context.Context, arg *CallbackFunc[func(context.Context, any) error]) error {
	if mod.lookupFuncMap.DictFree == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DictFree before")
	}
	mod.callbackFuncMap.DictFree[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DictDisc_freef", v.getPtr())
}

func (v *DictDisc) SetComparf(ctx context.Context, arg *CallbackFunc[func(context.Context, any, any) (int, error)]) error {
	if mod.lookupFuncMap.DictCompare == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DictCompare before")
	}
	mod.callbackFuncMap.DictCompare[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DictDisc_comparf", v.getPtr())
}

type Dict struct {
	ptr uint64
}

func NewDict(ctx context.Context) (*Dict, error) {
	o, err := mod.newObject(ctx, "Dict")
	if err != nil {
		return nil, err
	}
	return newDict(o), nil
}

func newDict(ptr uint64) *Dict {
	if ptr == 0 {
		return nil
	}
	return &Dict{ptr: ptr}
}

func (v *Dict) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newDictSlice(v []uint64) []*Dict {
	ret := make([]*Dict, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newDict(vv))
	}
	return ret
}
func (v *Dict) SetSearchf(ctx context.Context, arg *CallbackFunc[func(context.Context, *Dict, any, int) (any, error)]) error {
	if mod.lookupFuncMap.DictSearch == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DictSearch before")
	}
	mod.callbackFuncMap.DictSearch[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "Dict_searchf", v.getPtr())
}

func (v *Dict) SetDisc(_arg *DictDisc) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Dict_disc", v.getPtr(), arg)
}

func (v *Dict) GetDisc() *DictDisc {
	ret, err := v.getDisc(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Dict) getDisc(ctx context.Context) (*DictDisc, error) {
	var zero *DictDisc
	p, err := mod.getField(ctx, "Dict_disc", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictDisc(p)
	return ret, nil
}

func (v *Dict) SetData(_arg *DictData) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Dict_data", v.getPtr(), arg)
}

func (v *Dict) GetData() *DictData {
	ret, err := v.getData(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Dict) getData(ctx context.Context) (*DictData, error) {
	var zero *DictData
	p, err := mod.getField(ctx, "Dict_data", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictData(p)
	return ret, nil
}

func (v *Dict) SetMeth(_arg *DictMethod) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Dict_meth", v.getPtr(), arg)
}

func (v *Dict) GetMeth() *DictMethod {
	ret, err := v.getMeth(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Dict) getMeth(ctx context.Context) (*DictMethod, error) {
	var zero *DictMethod
	p, err := mod.getField(ctx, "Dict_meth", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictMethod(p)
	return ret, nil
}

func (v *Dict) SetNview(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Dict_nview", v.getPtr(), arg)
}

func (v *Dict) GetNview() int64 {
	ret, err := v.getNview(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Dict) getNview(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Dict_nview", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Dict) SetView(_arg *Dict) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Dict_view", v.getPtr(), arg)
}

func (v *Dict) GetView() *Dict {
	ret, err := v.getView(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Dict) getView(ctx context.Context) (*Dict, error) {
	var zero *Dict
	p, err := mod.getField(ctx, "Dict_view", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDict(p)
	return ret, nil
}

func (v *Dict) SetWalk(_arg *Dict) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Dict_walk", v.getPtr(), arg)
}

func (v *Dict) GetWalk() *Dict {
	ret, err := v.getWalk(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Dict) getWalk(ctx context.Context) (*Dict, error) {
	var zero *Dict
	p, err := mod.getField(ctx, "Dict_walk", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDict(p)
	return ret, nil
}

func (v *Dict) SetUser(_arg any) error {
	ctx := context.Background()
	arg, err := mod.toAnyWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Dict_user", v.getPtr(), arg)
}

func (v *Dict) GetUser() any {
	ret, err := v.getUser(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Dict) getUser(ctx context.Context) (any, error) {
	var zero any
	p, err := mod.getField(ctx, "Dict_user", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

type DictStat struct {
	ptr uint64
}

func NewDictStat(ctx context.Context) (*DictStat, error) {
	o, err := mod.newObject(ctx, "DictStat")
	if err != nil {
		return nil, err
	}
	return newDictStat(o), nil
}

func newDictStat(ptr uint64) *DictStat {
	if ptr == 0 {
		return nil
	}
	return &DictStat{ptr: ptr}
}

func (v *DictStat) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newDictStatSlice(v []uint64) []*DictStat {
	ret := make([]*DictStat, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newDictStat(vv))
	}
	return ret
}
func (v *DictStat) SetDtMeth(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictStat_dt_meth", v.getPtr(), arg)
}

func (v *DictStat) GetDtMeth() int64 {
	ret, err := v.getDtMeth(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictStat) getDtMeth(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "DictStat_dt_meth", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *DictStat) SetDtSize(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictStat_dt_size", v.getPtr(), arg)
}

func (v *DictStat) GetDtSize() int64 {
	ret, err := v.getDtSize(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictStat) getDtSize(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "DictStat_dt_size", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *DictStat) SetDtN(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictStat_dt_n", v.getPtr(), arg)
}

func (v *DictStat) GetDtN() uint64 {
	ret, err := v.getDtN(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictStat) getDtN(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "DictStat_dt_n", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *DictStat) SetDtMax(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictStat_dt_max", v.getPtr(), arg)
}

func (v *DictStat) GetDtMax() uint64 {
	ret, err := v.getDtMax(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictStat) getDtMax(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "DictStat_dt_max", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *DictStat) SetDtCount(_arg []uint32) error {
	ctx := context.Background()
	arg, err := mod.toUint32ArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DictStat_dt_count", v.getPtr(), arg)
}

func (v *DictStat) GetDtCount() []uint32 {
	ret, err := v.getDtCount(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DictStat) getDtCount(ctx context.Context) ([]uint32, error) {
	var zero []uint32
	p, err := mod.getField(ctx, "DictStat_dt_count", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := mod.toUint32Slice(slice)
	return ret, nil
}

type File struct {
	ptr uint64
}

func newFile(ptr uint64) *File {
	if ptr == 0 {
		return nil
	}
	return &File{ptr: ptr}
}

func (v *File) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newFileSlice(v []uint64) []*File {
	ret := make([]*File, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newFile(vv))
	}
	return ret
}

type Context struct {
	ptr uint64
}

func NewContext(ctx context.Context) (*Context, error) {
	o, err := mod.newObject(ctx, "Context")
	if err != nil {
		return nil, err
	}
	return newContext(o), nil
}

func newContext(ptr uint64) *Context {
	if ptr == 0 {
		return nil
	}
	return &Context{ptr: ptr}
}

func (v *Context) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newContextSlice(v []uint64) []*Context {
	ret := make([]*Context, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newContext(vv))
	}
	return ret
}
func (v *Context) SetCommon(_arg *Common) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Context_common", v.getPtr(), arg)
}

func (v *Context) GetCommon() *Common {
	ret, err := v.getCommon(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Context) getCommon(ctx context.Context) (*Common, error) {
	var zero *Common
	p, err := mod.getField(ctx, "Context_common", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newCommon(p)
	return ret, nil
}

func (v *Context) SetConfigPath(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Context_config_path", v.getPtr(), arg)
}

func (v *Context) GetConfigPath() string {
	ret, err := v.getConfigPath(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Context) getConfigPath(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Context_config_path", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Context) SetConfigFound(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Context_config_found", v.getPtr(), arg)
}

func (v *Context) GetConfigFound() bool {
	ret, err := v.getConfigFound(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Context) getConfigFound(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "Context_config_found", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *Context) SetInputFilenames(_arg []string) error {
	ctx := context.Background()
	arg, err := mod.toStringArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Context_input_filenames", v.getPtr(), arg)
}

func (v *Context) GetInputFilenames() []string {
	ret, err := v.getInputFilenames(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Context) getInputFilenames(ctx context.Context) ([]string, error) {
	var zero []string
	p, err := mod.getField(ctx, "Context_input_filenames", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toStringSlice(ctx, slice)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Context) SetApis(_arg []*PluginAvailable) error {
	ctx := context.Background()
	arg, err := mod.toObjectArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Context_apis", v.getPtr(), arg)
}

func (v *Context) GetApis() []*PluginAvailable {
	ret, err := v.getApis(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Context) getApis(ctx context.Context) ([]*PluginAvailable, error) {
	var zero []*PluginAvailable
	p, err := mod.getField(ctx, "Context_apis", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := newPluginAvailableSlice(slice)
	return ret, nil
}

func (v *Context) SetApi(_arg []*PluginAvailable) error {
	ctx := context.Background()
	arg, err := mod.toObjectArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Context_api", v.getPtr(), arg)
}

func (v *Context) GetApi() []*PluginAvailable {
	ret, err := v.getApi(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Context) getApi(ctx context.Context) ([]*PluginAvailable, error) {
	var zero []*PluginAvailable
	p, err := mod.getField(ctx, "Context_api", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := newPluginAvailableSlice(slice)
	return ret, nil
}

type PluginAvailable struct {
	ptr uint64
}

func NewPluginAvailable(ctx context.Context) (*PluginAvailable, error) {
	o, err := mod.newObject(ctx, "PluginAvailable")
	if err != nil {
		return nil, err
	}
	return newPluginAvailable(o), nil
}

func newPluginAvailable(ptr uint64) *PluginAvailable {
	if ptr == 0 {
		return nil
	}
	return &PluginAvailable{ptr: ptr}
}

func (v *PluginAvailable) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newPluginAvailableSlice(v []uint64) []*PluginAvailable {
	ret := make([]*PluginAvailable, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newPluginAvailable(vv))
	}
	return ret
}
func (v *PluginAvailable) SetNext(_arg *PluginAvailable) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginAvailable_next", v.getPtr(), arg)
}

func (v *PluginAvailable) GetNext() *PluginAvailable {
	ret, err := v.getNext(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginAvailable) getNext(ctx context.Context) (*PluginAvailable, error) {
	var zero *PluginAvailable
	p, err := mod.getField(ctx, "PluginAvailable_next", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPluginAvailable(p)
	return ret, nil
}

func (v *PluginAvailable) SetTypestr(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginAvailable_typestr", v.getPtr(), arg)
}

func (v *PluginAvailable) GetTypestr() string {
	ret, err := v.getTypestr(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginAvailable) getTypestr(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PluginAvailable_typestr", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PluginAvailable) SetQuality(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginAvailable_quality", v.getPtr(), arg)
}

func (v *PluginAvailable) GetQuality() int64 {
	ret, err := v.getQuality(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginAvailable) getQuality(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "PluginAvailable_quality", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *PluginAvailable) SetPackage(_arg *PluginPackage) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginAvailable_package", v.getPtr(), arg)
}

func (v *PluginAvailable) GetPackage() *PluginPackage {
	ret, err := v.getPackage(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginAvailable) getPackage(ctx context.Context) (*PluginPackage, error) {
	var zero *PluginPackage
	p, err := mod.getField(ctx, "PluginAvailable_package", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPluginPackage(p)
	return ret, nil
}

func (v *PluginAvailable) SetTypeptr(_arg *PluginInstalled) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginAvailable_typeptr", v.getPtr(), arg)
}

func (v *PluginAvailable) GetTypeptr() *PluginInstalled {
	ret, err := v.getTypeptr(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginAvailable) getTypeptr(ctx context.Context) (*PluginInstalled, error) {
	var zero *PluginInstalled
	p, err := mod.getField(ctx, "PluginAvailable_typeptr", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPluginInstalled(p)
	return ret, nil
}

type PluginPackage struct {
	ptr uint64
}

func NewPluginPackage(ctx context.Context) (*PluginPackage, error) {
	o, err := mod.newObject(ctx, "PluginPackage")
	if err != nil {
		return nil, err
	}
	return newPluginPackage(o), nil
}

func newPluginPackage(ptr uint64) *PluginPackage {
	if ptr == 0 {
		return nil
	}
	return &PluginPackage{ptr: ptr}
}

func (v *PluginPackage) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newPluginPackageSlice(v []uint64) []*PluginPackage {
	ret := make([]*PluginPackage, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newPluginPackage(vv))
	}
	return ret
}
func (v *PluginPackage) SetNext(_arg *PluginPackage) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginPackage_next", v.getPtr(), arg)
}

func (v *PluginPackage) GetNext() *PluginPackage {
	ret, err := v.getNext(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginPackage) getNext(ctx context.Context) (*PluginPackage, error) {
	var zero *PluginPackage
	p, err := mod.getField(ctx, "PluginPackage_next", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPluginPackage(p)
	return ret, nil
}

func (v *PluginPackage) SetPath(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginPackage_path", v.getPtr(), arg)
}

func (v *PluginPackage) GetPath() string {
	ret, err := v.getPath(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginPackage) getPath(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PluginPackage_path", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PluginPackage) SetName(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginPackage_name", v.getPtr(), arg)
}

func (v *PluginPackage) GetName() string {
	ret, err := v.getName(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginPackage) getName(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PluginPackage_name", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

type SymList struct {
	ptr uint64
}

func NewSymList(ctx context.Context) (*SymList, error) {
	o, err := mod.newObject(ctx, "SymList")
	if err != nil {
		return nil, err
	}
	return newSymList(o), nil
}

func newSymList(ptr uint64) *SymList {
	if ptr == 0 {
		return nil
	}
	return &SymList{ptr: ptr}
}

func (v *SymList) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newSymListSlice(v []uint64) []*SymList {
	ret := make([]*SymList, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newSymList(vv))
	}
	return ret
}
func (v *SymList) SetName(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "SymList_name", v.getPtr(), arg)
}

func (v *SymList) GetName() string {
	ret, err := v.getName(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *SymList) getName(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "SymList_name", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *SymList) SetAddress(_arg *PluginLibrary) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "SymList_address", v.getPtr(), arg)
}

func (v *SymList) GetAddress() *PluginLibrary {
	ret, err := v.getAddress(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *SymList) getAddress(ctx context.Context) (*PluginLibrary, error) {
	var zero *PluginLibrary
	p, err := mod.getField(ctx, "SymList_address", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPluginLibrary(p)
	return ret, nil
}

type UserShape struct {
	ptr uint64
}

func NewUserShape(ctx context.Context) (*UserShape, error) {
	o, err := mod.newObject(ctx, "UserShape")
	if err != nil {
		return nil, err
	}
	return newUserShape(o), nil
}

func newUserShape(ptr uint64) *UserShape {
	if ptr == 0 {
		return nil
	}
	return &UserShape{ptr: ptr}
}

func (v *UserShape) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newUserShapeSlice(v []uint64) []*UserShape {
	ret := make([]*UserShape, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newUserShape(vv))
	}
	return ret
}
func (v *UserShape) SetLink(_arg *DictLink) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_link", v.getPtr(), arg)
}

func (v *UserShape) GetLink() *DictLink {
	ret, err := v.getLink(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getLink(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.getField(ctx, "UserShape_link", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *UserShape) SetName(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_name", v.getPtr(), arg)
}

func (v *UserShape) GetName() string {
	ret, err := v.getName(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getName(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "UserShape_name", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *UserShape) SetMacroId(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_macro_id", v.getPtr(), arg)
}

func (v *UserShape) GetMacroId() int64 {
	ret, err := v.getMacroId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getMacroId(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "UserShape_macro_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *UserShape) SetMustInline(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_must_inline", v.getPtr(), arg)
}

func (v *UserShape) GetMustInline() bool {
	ret, err := v.getMustInline(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getMustInline(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "UserShape_must_inline", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *UserShape) SetNocache(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_nocache", v.getPtr(), arg)
}

func (v *UserShape) GetNocache() bool {
	ret, err := v.getNocache(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getNocache(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "UserShape_nocache", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *UserShape) SetF(_arg *File) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_f", v.getPtr(), arg)
}

func (v *UserShape) GetF() *File {
	ret, err := v.getF(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getF(ctx context.Context) (*File, error) {
	var zero *File
	p, err := mod.getField(ctx, "UserShape_f", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newFile(p)
	return ret, nil
}

func (v *UserShape) SetType(_arg ImageType) error {
	ctx := context.Background()
	arg, err := mod.toIntWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_type", v.getPtr(), arg)
}

func (v *UserShape) GetType() ImageType {
	ret, err := v.getType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getType(ctx context.Context) (ImageType, error) {
	var zero ImageType
	p, err := mod.getField(ctx, "UserShape_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := ImageType(p)
	return ret, nil
}

func (v *UserShape) SetStringtype(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_stringtype", v.getPtr(), arg)
}

func (v *UserShape) GetStringtype() string {
	ret, err := v.getStringtype(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getStringtype(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "UserShape_stringtype", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *UserShape) SetX(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_x", v.getPtr(), arg)
}

func (v *UserShape) GetX() int64 {
	ret, err := v.getX(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getX(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "UserShape_x", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *UserShape) SetY(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_y", v.getPtr(), arg)
}

func (v *UserShape) GetY() int64 {
	ret, err := v.getY(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getY(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "UserShape_y", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *UserShape) SetW(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_w", v.getPtr(), arg)
}

func (v *UserShape) GetW() int64 {
	ret, err := v.getW(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getW(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "UserShape_w", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *UserShape) SetH(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_h", v.getPtr(), arg)
}

func (v *UserShape) GetH() int64 {
	ret, err := v.getH(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getH(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "UserShape_h", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *UserShape) SetDpi(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_dpi", v.getPtr(), arg)
}

func (v *UserShape) GetDpi() int64 {
	ret, err := v.getDpi(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getDpi(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "UserShape_dpi", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *UserShape) SetData(_arg any) error {
	ctx := context.Background()
	arg, err := mod.toAnyWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_data", v.getPtr(), arg)
}

func (v *UserShape) GetData() any {
	ret, err := v.getData(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getData(ctx context.Context) (any, error) {
	var zero any
	p, err := mod.getField(ctx, "UserShape_data", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

func (v *UserShape) SetDatasize(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "UserShape_datasize", v.getPtr(), arg)
}

func (v *UserShape) GetDatasize() uint64 {
	ret, err := v.getDatasize(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *UserShape) getDatasize(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "UserShape_datasize", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *UserShape) SetDatafree(ctx context.Context, arg *CallbackFunc[func(context.Context, *UserShape) error]) error {
	if mod.lookupFuncMap.UserShape_DataFree == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_UserShape_DataFree before")
	}
	mod.callbackFuncMap.UserShape_DataFree[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "UserShape_datafree", v.getPtr())
}

type PluginActiveLoadImage struct {
	ptr uint64
}

func NewPluginActiveLoadImage(ctx context.Context) (*PluginActiveLoadImage, error) {
	o, err := mod.newObject(ctx, "PluginActiveLoadImage")
	if err != nil {
		return nil, err
	}
	return newPluginActiveLoadImage(o), nil
}

func newPluginActiveLoadImage(ptr uint64) *PluginActiveLoadImage {
	if ptr == 0 {
		return nil
	}
	return &PluginActiveLoadImage{ptr: ptr}
}

func (v *PluginActiveLoadImage) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newPluginActiveLoadImageSlice(v []uint64) []*PluginActiveLoadImage {
	ret := make([]*PluginActiveLoadImage, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newPluginActiveLoadImage(vv))
	}
	return ret
}
func (v *PluginActiveLoadImage) SetEngine(_arg *LoadImageEngine) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginActiveLoadImage_engine", v.getPtr(), arg)
}

func (v *PluginActiveLoadImage) GetEngine() *LoadImageEngine {
	ret, err := v.getEngine(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginActiveLoadImage) getEngine(ctx context.Context) (*LoadImageEngine, error) {
	var zero *LoadImageEngine
	p, err := mod.getField(ctx, "PluginActiveLoadImage_engine", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newLoadImageEngine(p)
	return ret, nil
}

func (v *PluginActiveLoadImage) SetId(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginActiveLoadImage_id", v.getPtr(), arg)
}

func (v *PluginActiveLoadImage) GetId() int64 {
	ret, err := v.getId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginActiveLoadImage) getId(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "PluginActiveLoadImage_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *PluginActiveLoadImage) SetType(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginActiveLoadImage_type", v.getPtr(), arg)
}

func (v *PluginActiveLoadImage) GetType() string {
	ret, err := v.getType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginActiveLoadImage) getType(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PluginActiveLoadImage_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

type Common struct {
	ptr uint64
}

func NewCommon(ctx context.Context) (*Common, error) {
	o, err := mod.newObject(ctx, "Common")
	if err != nil {
		return nil, err
	}
	return newCommon(o), nil
}

func newCommon(ptr uint64) *Common {
	if ptr == 0 {
		return nil
	}
	return &Common{ptr: ptr}
}

func (v *Common) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newCommonSlice(v []uint64) []*Common {
	ret := make([]*Common, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newCommon(vv))
	}
	return ret
}
func (v *Common) SetInfo(_arg []string) error {
	ctx := context.Background()
	arg, err := mod.toStringArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Common_info", v.getPtr(), arg)
}

func (v *Common) GetInfo() []string {
	ret, err := v.getInfo(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Common) getInfo(ctx context.Context) ([]string, error) {
	var zero []string
	p, err := mod.getField(ctx, "Common_info", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toStringSlice(ctx, slice)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Common) SetCmdname(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Common_cmdname", v.getPtr(), arg)
}

func (v *Common) GetCmdname() string {
	ret, err := v.getCmdname(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Common) getCmdname(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Common_cmdname", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Common) SetVerbose(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Common_verbose", v.getPtr(), arg)
}

func (v *Common) GetVerbose() int64 {
	ret, err := v.getVerbose(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Common) getVerbose(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Common_verbose", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Common) SetConfig(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Common_config", v.getPtr(), arg)
}

func (v *Common) GetConfig() bool {
	ret, err := v.getConfig(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Common) getConfig(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "Common_config", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *Common) SetAutoOutfileNames(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Common_auto_outfile_names", v.getPtr(), arg)
}

func (v *Common) GetAutoOutfileNames() bool {
	ret, err := v.getAutoOutfileNames(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Common) getAutoOutfileNames(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "Common_auto_outfile_names", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *Common) SetShowBoxes(_arg []string) error {
	ctx := context.Background()
	arg, err := mod.toStringArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Common_show_boxes", v.getPtr(), arg)
}

func (v *Common) GetShowBoxes() []string {
	ret, err := v.getShowBoxes(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Common) getShowBoxes(ctx context.Context) ([]string, error) {
	var zero []string
	p, err := mod.getField(ctx, "Common_show_boxes", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toStringSlice(ctx, slice)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Common) SetLib(_arg []string) error {
	ctx := context.Background()
	arg, err := mod.toStringArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Common_lib", v.getPtr(), arg)
}

func (v *Common) GetLib() []string {
	ret, err := v.getLib(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Common) getLib(ctx context.Context) ([]string, error) {
	var zero []string
	p, err := mod.getField(ctx, "Common_lib", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toStringSlice(ctx, slice)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Common) SetViewNum(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Common_view_num", v.getPtr(), arg)
}

func (v *Common) GetViewNum() int64 {
	ret, err := v.getViewNum(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Common) getViewNum(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Common_view_num", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Common) SetBuiltins(_arg *SymList) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Common_builtins", v.getPtr(), arg)
}

func (v *Common) GetBuiltins() *SymList {
	ret, err := v.getBuiltins(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Common) getBuiltins(ctx context.Context) (*SymList, error) {
	var zero *SymList
	p, err := mod.getField(ctx, "Common_builtins", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newSymList(p)
	return ret, nil
}

func (v *Common) SetDemandLoading(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Common_demand_loading", v.getPtr(), arg)
}

func (v *Common) GetDemandLoading() int64 {
	ret, err := v.getDemandLoading(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Common) getDemandLoading(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Common_demand_loading", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

type ObjectState struct {
	ptr uint64
}

func NewObjectState(ctx context.Context) (*ObjectState, error) {
	o, err := mod.newObject(ctx, "ObjectState")
	if err != nil {
		return nil, err
	}
	return newObjectState(o), nil
}

func newObjectState(ptr uint64) *ObjectState {
	if ptr == 0 {
		return nil
	}
	return &ObjectState{ptr: ptr}
}

func (v *ObjectState) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newObjectStateSlice(v []uint64) []*ObjectState {
	ret := make([]*ObjectState, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newObjectState(vv))
	}
	return ret
}
func (v *ObjectState) SetParent(_arg *ObjectState) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_parent", v.getPtr(), arg)
}

func (v *ObjectState) GetParent() *ObjectState {
	ret, err := v.getParent(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getParent(ctx context.Context) (*ObjectState, error) {
	var zero *ObjectState
	p, err := mod.getField(ctx, "ObjectState_parent", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newObjectState(p)
	return ret, nil
}

func (v *ObjectState) SetType(_arg ObjectType) error {
	ctx := context.Background()
	arg, err := mod.toIntWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_type", v.getPtr(), arg)
}

func (v *ObjectState) GetType() ObjectType {
	ret, err := v.getType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getType(ctx context.Context) (ObjectType, error) {
	var zero ObjectType
	p, err := mod.getField(ctx, "ObjectState_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := ObjectType(p)
	return ret, nil
}

func (v *ObjectState) SetG(_arg *Graph) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_g", v.getPtr(), arg)
}

func (v *ObjectState) GetG() *Graph {
	ret, err := v.getG(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getG(ctx context.Context) (*Graph, error) {
	var zero *Graph
	p, err := mod.getField(ctx, "ObjectState_g", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *ObjectState) SetSg(_arg *Graph) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_sg", v.getPtr(), arg)
}

func (v *ObjectState) GetSg() *Graph {
	ret, err := v.getSg(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getSg(ctx context.Context) (*Graph, error) {
	var zero *Graph
	p, err := mod.getField(ctx, "ObjectState_sg", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *ObjectState) SetN(_arg *Node) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_n", v.getPtr(), arg)
}

func (v *ObjectState) GetN() *Node {
	ret, err := v.getN(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getN(ctx context.Context) (*Node, error) {
	var zero *Node
	p, err := mod.getField(ctx, "ObjectState_n", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newNode(p)
	return ret, nil
}

func (v *ObjectState) SetE(_arg *Edge) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_e", v.getPtr(), arg)
}

func (v *ObjectState) GetE() *Edge {
	ret, err := v.getE(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getE(ctx context.Context) (*Edge, error) {
	var zero *Edge
	p, err := mod.getField(ctx, "ObjectState_e", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

func (v *ObjectState) SetEmitState(_arg EmitState) error {
	ctx := context.Background()
	arg, err := mod.toIntWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_emit_state", v.getPtr(), arg)
}

func (v *ObjectState) GetEmitState() EmitState {
	ret, err := v.getEmitState(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getEmitState(ctx context.Context) (EmitState, error) {
	var zero EmitState
	p, err := mod.getField(ctx, "ObjectState_emit_state", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := EmitState(p)
	return ret, nil
}

func (v *ObjectState) SetPencolor(_arg *Color) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_pencolor", v.getPtr(), arg)
}

func (v *ObjectState) GetPencolor() *Color {
	ret, err := v.getPencolor(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getPencolor(ctx context.Context) (*Color, error) {
	var zero *Color
	p, err := mod.getField(ctx, "ObjectState_pencolor", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newColor(p)
	return ret, nil
}

func (v *ObjectState) SetFillcolor(_arg *Color) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_fillcolor", v.getPtr(), arg)
}

func (v *ObjectState) GetFillcolor() *Color {
	ret, err := v.getFillcolor(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getFillcolor(ctx context.Context) (*Color, error) {
	var zero *Color
	p, err := mod.getField(ctx, "ObjectState_fillcolor", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newColor(p)
	return ret, nil
}

func (v *ObjectState) SetStopcolor(_arg *Color) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_stopcolor", v.getPtr(), arg)
}

func (v *ObjectState) GetStopcolor() *Color {
	ret, err := v.getStopcolor(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getStopcolor(ctx context.Context) (*Color, error) {
	var zero *Color
	p, err := mod.getField(ctx, "ObjectState_stopcolor", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newColor(p)
	return ret, nil
}

func (v *ObjectState) SetGradientAngle(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_gradient_angle", v.getPtr(), arg)
}

func (v *ObjectState) GetGradientAngle() int64 {
	ret, err := v.getGradientAngle(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getGradientAngle(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "ObjectState_gradient_angle", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *ObjectState) SetGradientFrac(_arg float32) error {
	ctx := context.Background()
	arg, err := mod.toFloatWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_gradient_frac", v.getPtr(), arg)
}

func (v *ObjectState) GetGradientFrac() float32 {
	ret, err := v.getGradientFrac(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getGradientFrac(ctx context.Context) (float32, error) {
	var zero float32
	p, err := mod.getField(ctx, "ObjectState_gradient_frac", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat32(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetPen(_arg PenType) error {
	ctx := context.Background()
	arg, err := mod.toIntWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_pen", v.getPtr(), arg)
}

func (v *ObjectState) GetPen() PenType {
	ret, err := v.getPen(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getPen(ctx context.Context) (PenType, error) {
	var zero PenType
	p, err := mod.getField(ctx, "ObjectState_pen", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := PenType(p)
	return ret, nil
}

func (v *ObjectState) SetFill(_arg FillType) error {
	ctx := context.Background()
	arg, err := mod.toIntWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_fill", v.getPtr(), arg)
}

func (v *ObjectState) GetFill() FillType {
	ret, err := v.getFill(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getFill(ctx context.Context) (FillType, error) {
	var zero FillType
	p, err := mod.getField(ctx, "ObjectState_fill", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := FillType(p)
	return ret, nil
}

func (v *ObjectState) SetPenwidth(_arg float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_penwidth", v.getPtr(), arg)
}

func (v *ObjectState) GetPenwidth() float64 {
	ret, err := v.getPenwidth(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getPenwidth(ctx context.Context) (float64, error) {
	var zero float64
	p, err := mod.getField(ctx, "ObjectState_penwidth", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetRawstyle(_arg []string) error {
	ctx := context.Background()
	arg, err := mod.toStringArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_rawstyle", v.getPtr(), arg)
}

func (v *ObjectState) GetRawstyle() []string {
	ret, err := v.getRawstyle(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getRawstyle(ctx context.Context) ([]string, error) {
	var zero []string
	p, err := mod.getField(ctx, "ObjectState_rawstyle", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toStringSlice(ctx, slice)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetZ(_arg float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_z", v.getPtr(), arg)
}

func (v *ObjectState) GetZ() float64 {
	ret, err := v.getZ(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getZ(ctx context.Context) (float64, error) {
	var zero float64
	p, err := mod.getField(ctx, "ObjectState_z", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetTailZ(_arg float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_tail_z", v.getPtr(), arg)
}

func (v *ObjectState) GetTailZ() float64 {
	ret, err := v.getTailZ(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getTailZ(ctx context.Context) (float64, error) {
	var zero float64
	p, err := mod.getField(ctx, "ObjectState_tail_z", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetHeadZ(_arg float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_head_z", v.getPtr(), arg)
}

func (v *ObjectState) GetHeadZ() float64 {
	ret, err := v.getHeadZ(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getHeadZ(ctx context.Context) (float64, error) {
	var zero float64
	p, err := mod.getField(ctx, "ObjectState_head_z", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetLabel(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_label", v.getPtr(), arg)
}

func (v *ObjectState) GetLabel() string {
	ret, err := v.getLabel(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getLabel(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_label", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetXlabel(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_xlabel", v.getPtr(), arg)
}

func (v *ObjectState) GetXlabel() string {
	ret, err := v.getXlabel(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getXlabel(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_xlabel", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetTaillabel(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_taillabel", v.getPtr(), arg)
}

func (v *ObjectState) GetTaillabel() string {
	ret, err := v.getTaillabel(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getTaillabel(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_taillabel", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetHeadlabel(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_headlabel", v.getPtr(), arg)
}

func (v *ObjectState) GetHeadlabel() string {
	ret, err := v.getHeadlabel(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getHeadlabel(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_headlabel", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetUrl(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_url", v.getPtr(), arg)
}

func (v *ObjectState) GetUrl() string {
	ret, err := v.getUrl(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getUrl(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_url", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetId(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_id", v.getPtr(), arg)
}

func (v *ObjectState) GetId() string {
	ret, err := v.getId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getId(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetLabelurl(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_labelurl", v.getPtr(), arg)
}

func (v *ObjectState) GetLabelurl() string {
	ret, err := v.getLabelurl(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getLabelurl(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_labelurl", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetTailurl(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_tailurl", v.getPtr(), arg)
}

func (v *ObjectState) GetTailurl() string {
	ret, err := v.getTailurl(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getTailurl(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_tailurl", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetHeadurl(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_headurl", v.getPtr(), arg)
}

func (v *ObjectState) GetHeadurl() string {
	ret, err := v.getHeadurl(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getHeadurl(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_headurl", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetTooltip(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_tooltip", v.getPtr(), arg)
}

func (v *ObjectState) GetTooltip() string {
	ret, err := v.getTooltip(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getTooltip(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_tooltip", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetLabeltooltip(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_labeltooltip", v.getPtr(), arg)
}

func (v *ObjectState) GetLabeltooltip() string {
	ret, err := v.getLabeltooltip(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getLabeltooltip(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_labeltooltip", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetTailtooltip(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_tailtooltip", v.getPtr(), arg)
}

func (v *ObjectState) GetTailtooltip() string {
	ret, err := v.getTailtooltip(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getTailtooltip(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_tailtooltip", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetHeadtooltip(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_headtooltip", v.getPtr(), arg)
}

func (v *ObjectState) GetHeadtooltip() string {
	ret, err := v.getHeadtooltip(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getHeadtooltip(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_headtooltip", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetTarget(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_target", v.getPtr(), arg)
}

func (v *ObjectState) GetTarget() string {
	ret, err := v.getTarget(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getTarget(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_target", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetLabeltarget(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_labeltarget", v.getPtr(), arg)
}

func (v *ObjectState) GetLabeltarget() string {
	ret, err := v.getLabeltarget(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getLabeltarget(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_labeltarget", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetTailtarget(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_tailtarget", v.getPtr(), arg)
}

func (v *ObjectState) GetTailtarget() string {
	ret, err := v.getTailtarget(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getTailtarget(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_tailtarget", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetHeadtarget(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_headtarget", v.getPtr(), arg)
}

func (v *ObjectState) GetHeadtarget() string {
	ret, err := v.getHeadtarget(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getHeadtarget(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "ObjectState_headtarget", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *ObjectState) SetExplicitTooltip(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_explicit_tooltip", v.getPtr(), arg)
}

func (v *ObjectState) GetExplicitTooltip() uint64 {
	ret, err := v.getExplicitTooltip(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getExplicitTooltip(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "ObjectState_explicit_tooltip", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *ObjectState) SetExplicitTailtooltip(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_explicit_tailtooltip", v.getPtr(), arg)
}

func (v *ObjectState) GetExplicitTailtooltip() uint64 {
	ret, err := v.getExplicitTailtooltip(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getExplicitTailtooltip(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "ObjectState_explicit_tailtooltip", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *ObjectState) SetExplicitHeadtooltip(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_explicit_headtooltip", v.getPtr(), arg)
}

func (v *ObjectState) GetExplicitHeadtooltip() uint64 {
	ret, err := v.getExplicitHeadtooltip(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getExplicitHeadtooltip(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "ObjectState_explicit_headtooltip", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *ObjectState) SetExplicitLabeltooltip(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_explicit_labeltooltip", v.getPtr(), arg)
}

func (v *ObjectState) GetExplicitLabeltooltip() uint64 {
	ret, err := v.getExplicitLabeltooltip(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getExplicitLabeltooltip(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "ObjectState_explicit_labeltooltip", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *ObjectState) SetExplicitTailtarget(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_explicit_tailtarget", v.getPtr(), arg)
}

func (v *ObjectState) GetExplicitTailtarget() uint64 {
	ret, err := v.getExplicitTailtarget(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getExplicitTailtarget(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "ObjectState_explicit_tailtarget", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *ObjectState) SetExplicitHeadtarget(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_explicit_headtarget", v.getPtr(), arg)
}

func (v *ObjectState) GetExplicitHeadtarget() uint64 {
	ret, err := v.getExplicitHeadtarget(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getExplicitHeadtarget(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "ObjectState_explicit_headtarget", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *ObjectState) SetExplicitEdgetarget(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_explicit_edgetarget", v.getPtr(), arg)
}

func (v *ObjectState) GetExplicitEdgetarget() uint64 {
	ret, err := v.getExplicitEdgetarget(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getExplicitEdgetarget(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "ObjectState_explicit_edgetarget", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *ObjectState) SetExplicitTailurl(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_explicit_tailurl", v.getPtr(), arg)
}

func (v *ObjectState) GetExplicitTailurl() uint64 {
	ret, err := v.getExplicitTailurl(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getExplicitTailurl(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "ObjectState_explicit_tailurl", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *ObjectState) SetExplicitHeadurl(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_explicit_headurl", v.getPtr(), arg)
}

func (v *ObjectState) GetExplicitHeadurl() uint64 {
	ret, err := v.getExplicitHeadurl(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getExplicitHeadurl(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "ObjectState_explicit_headurl", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *ObjectState) SetLabeledgealigned(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_labeledgealigned", v.getPtr(), arg)
}

func (v *ObjectState) GetLabeledgealigned() uint64 {
	ret, err := v.getLabeledgealigned(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getLabeledgealigned(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "ObjectState_labeledgealigned", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *ObjectState) SetUrlMapShape(_arg MapShapeType) error {
	ctx := context.Background()
	arg, err := mod.toIntWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_url_map_shape", v.getPtr(), arg)
}

func (v *ObjectState) GetUrlMapShape() MapShapeType {
	ret, err := v.getUrlMapShape(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getUrlMapShape(ctx context.Context) (MapShapeType, error) {
	var zero MapShapeType
	p, err := mod.getField(ctx, "ObjectState_url_map_shape", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := MapShapeType(p)
	return ret, nil
}

func (v *ObjectState) SetUrlMapN(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_url_map_n", v.getPtr(), arg)
}

func (v *ObjectState) GetUrlMapN() uint64 {
	ret, err := v.getUrlMapN(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getUrlMapN(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "ObjectState_url_map_n", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *ObjectState) SetUrlMapP(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_url_map_p", v.getPtr(), arg)
}

func (v *ObjectState) GetUrlMapP() *PointFloat {
	ret, err := v.getUrlMapP(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getUrlMapP(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "ObjectState_url_map_p", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *ObjectState) SetUrlBsplinemapPolyN(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_url_bsplinemap_poly_n", v.getPtr(), arg)
}

func (v *ObjectState) GetUrlBsplinemapPolyN() int64 {
	ret, err := v.getUrlBsplinemapPolyN(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getUrlBsplinemapPolyN(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "ObjectState_url_bsplinemap_poly_n", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *ObjectState) SetUrlBsplinemapN(_arg []int) error {
	ctx := context.Background()
	arg, err := mod.toIntArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_url_bsplinemap_n", v.getPtr(), arg)
}

func (v *ObjectState) GetUrlBsplinemapN() []int {
	ret, err := v.getUrlBsplinemapN(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getUrlBsplinemapN(ctx context.Context) ([]int, error) {
	var zero []int
	p, err := mod.getField(ctx, "ObjectState_url_bsplinemap_n", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := mod.toIntSlice(slice)
	return ret, nil
}

func (v *ObjectState) SetUrlBsplinemapP(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_url_bsplinemap_p", v.getPtr(), arg)
}

func (v *ObjectState) GetUrlBsplinemapP() *PointFloat {
	ret, err := v.getUrlBsplinemapP(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getUrlBsplinemapP(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "ObjectState_url_bsplinemap_p", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *ObjectState) SetTailendurlMapN(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_tailendurl_map_n", v.getPtr(), arg)
}

func (v *ObjectState) GetTailendurlMapN() int64 {
	ret, err := v.getTailendurlMapN(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getTailendurlMapN(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "ObjectState_tailendurl_map_n", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *ObjectState) SetTailendurlMapP(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_tailendurl_map_p", v.getPtr(), arg)
}

func (v *ObjectState) GetTailendurlMapP() *PointFloat {
	ret, err := v.getTailendurlMapP(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getTailendurlMapP(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "ObjectState_tailendurl_map_p", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *ObjectState) SetHeadendurlMapN(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_headendurl_map_n", v.getPtr(), arg)
}

func (v *ObjectState) GetHeadendurlMapN() int64 {
	ret, err := v.getHeadendurlMapN(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getHeadendurlMapN(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "ObjectState_headendurl_map_n", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *ObjectState) SetHeadendurlMapP(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "ObjectState_headendurl_map_p", v.getPtr(), arg)
}

func (v *ObjectState) GetHeadendurlMapP() *PointFloat {
	ret, err := v.getHeadendurlMapP(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *ObjectState) getHeadendurlMapP(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "ObjectState_headendurl_map_p", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

type DeviceCallbacks struct {
	ptr uint64
}

func NewDeviceCallbacks(ctx context.Context) (*DeviceCallbacks, error) {
	o, err := mod.newObject(ctx, "DeviceCallbacks")
	if err != nil {
		return nil, err
	}
	return newDeviceCallbacks(o), nil
}

func newDeviceCallbacks(ptr uint64) *DeviceCallbacks {
	if ptr == 0 {
		return nil
	}
	return &DeviceCallbacks{ptr: ptr}
}

func (v *DeviceCallbacks) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newDeviceCallbacksSlice(v []uint64) []*DeviceCallbacks {
	ret := make([]*DeviceCallbacks, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newDeviceCallbacks(vv))
	}
	return ret
}
func (v *DeviceCallbacks) SetRefresh(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.DeviceCallbacks_Refresh == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceCallbacks_Refresh before")
	}
	mod.callbackFuncMap.DeviceCallbacks_Refresh[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceCallbacks_refresh", v.getPtr())
}

func (v *DeviceCallbacks) SetButtonPress(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, int, *PointFloat) error]) error {
	if mod.lookupFuncMap.DeviceCallbacks_ButtonPress == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceCallbacks_ButtonPress before")
	}
	mod.callbackFuncMap.DeviceCallbacks_ButtonPress[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceCallbacks_button_press", v.getPtr())
}

func (v *DeviceCallbacks) SetButtonRelease(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, int, *PointFloat) error]) error {
	if mod.lookupFuncMap.DeviceCallbacks_ButtonRelease == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceCallbacks_ButtonRelease before")
	}
	mod.callbackFuncMap.DeviceCallbacks_ButtonRelease[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceCallbacks_button_release", v.getPtr())
}

func (v *DeviceCallbacks) SetMotion(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, *PointFloat) error]) error {
	if mod.lookupFuncMap.DeviceCallbacks_Motion == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceCallbacks_Motion before")
	}
	mod.callbackFuncMap.DeviceCallbacks_Motion[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceCallbacks_motion", v.getPtr())
}

func (v *DeviceCallbacks) SetModify(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, string, string) error]) error {
	if mod.lookupFuncMap.DeviceCallbacks_Modify == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceCallbacks_Modify before")
	}
	mod.callbackFuncMap.DeviceCallbacks_Modify[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceCallbacks_modify", v.getPtr())
}

func (v *DeviceCallbacks) SetDel(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.DeviceCallbacks_Delete == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceCallbacks_Delete before")
	}
	mod.callbackFuncMap.DeviceCallbacks_Delete[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceCallbacks_del", v.getPtr())
}

func (v *DeviceCallbacks) SetRead(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, string, string) error]) error {
	if mod.lookupFuncMap.DeviceCallbacks_Read == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceCallbacks_Read before")
	}
	mod.callbackFuncMap.DeviceCallbacks_Read[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceCallbacks_read", v.getPtr())
}

func (v *DeviceCallbacks) SetLayout(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, string) error]) error {
	if mod.lookupFuncMap.DeviceCallbacks_Layout == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceCallbacks_Layout before")
	}
	mod.callbackFuncMap.DeviceCallbacks_Layout[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceCallbacks_layout", v.getPtr())
}

func (v *DeviceCallbacks) SetRender(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, string, string) error]) error {
	if mod.lookupFuncMap.DeviceCallbacks_Render == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceCallbacks_Render before")
	}
	mod.callbackFuncMap.DeviceCallbacks_Render[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceCallbacks_render", v.getPtr())
}

type Job struct {
	ptr uint64
}

func NewJob(ctx context.Context) (*Job, error) {
	o, err := mod.newObject(ctx, "Job")
	if err != nil {
		return nil, err
	}
	return newJob(o), nil
}

func newJob(ptr uint64) *Job {
	if ptr == 0 {
		return nil
	}
	return &Job{ptr: ptr}
}

func (v *Job) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newJobSlice(v []uint64) []*Job {
	ret := make([]*Job, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newJob(vv))
	}
	return ret
}
func (v *Job) SetGvc(_arg *Context) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_gvc", v.getPtr(), arg)
}

func (v *Job) GetGvc() *Context {
	ret, err := v.getGvc(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getGvc(ctx context.Context) (*Context, error) {
	var zero *Context
	p, err := mod.getField(ctx, "Job_gvc", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newContext(p)
	return ret, nil
}

func (v *Job) SetNext(_arg *Job) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_next", v.getPtr(), arg)
}

func (v *Job) GetNext() *Job {
	ret, err := v.getNext(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getNext(ctx context.Context) (*Job, error) {
	var zero *Job
	p, err := mod.getField(ctx, "Job_next", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newJob(p)
	return ret, nil
}

func (v *Job) SetNextActive(_arg *Job) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_next_active", v.getPtr(), arg)
}

func (v *Job) GetNextActive() *Job {
	ret, err := v.getNextActive(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getNextActive(ctx context.Context) (*Job, error) {
	var zero *Job
	p, err := mod.getField(ctx, "Job_next_active", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newJob(p)
	return ret, nil
}

func (v *Job) SetCommon(_arg *Common) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_common", v.getPtr(), arg)
}

func (v *Job) GetCommon() *Common {
	ret, err := v.getCommon(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getCommon(ctx context.Context) (*Common, error) {
	var zero *Common
	p, err := mod.getField(ctx, "Job_common", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newCommon(p)
	return ret, nil
}

func (v *Job) SetObj(_arg *ObjectState) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_obj", v.getPtr(), arg)
}

func (v *Job) GetObj() *ObjectState {
	ret, err := v.getObj(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getObj(ctx context.Context) (*ObjectState, error) {
	var zero *ObjectState
	p, err := mod.getField(ctx, "Job_obj", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newObjectState(p)
	return ret, nil
}

func (v *Job) SetInputFilename(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_input_filename", v.getPtr(), arg)
}

func (v *Job) GetInputFilename() string {
	ret, err := v.getInputFilename(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getInputFilename(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Job_input_filename", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Job) SetGraphIndex(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_graph_index", v.getPtr(), arg)
}

func (v *Job) GetGraphIndex() int64 {
	ret, err := v.getGraphIndex(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getGraphIndex(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Job_graph_index", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Job) SetLayoutType(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_layout_type", v.getPtr(), arg)
}

func (v *Job) GetLayoutType() string {
	ret, err := v.getLayoutType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getLayoutType(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Job_layout_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Job) SetOutputFilename(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_output_filename", v.getPtr(), arg)
}

func (v *Job) GetOutputFilename() string {
	ret, err := v.getOutputFilename(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getOutputFilename(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Job_output_filename", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Job) SetOutputFile(_arg *File) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_output_file", v.getPtr(), arg)
}

func (v *Job) GetOutputFile() *File {
	ret, err := v.getOutputFile(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getOutputFile(ctx context.Context) (*File, error) {
	var zero *File
	p, err := mod.getField(ctx, "Job_output_file", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newFile(p)
	return ret, nil
}

func (v *Job) SetOutputData(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_output_data", v.getPtr(), arg)
}

func (v *Job) GetOutputData() string {
	ret, err := v.getOutputData(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getOutputData(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Job_output_data", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Job) SetOutputDataAllocated(_arg uint) error {
	ctx := context.Background()
	arg, err := mod.toUintWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_output_data_allocated", v.getPtr(), arg)
}

func (v *Job) GetOutputDataAllocated() uint {
	ret, err := v.getOutputDataAllocated(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getOutputDataAllocated(ctx context.Context) (uint, error) {
	var zero uint
	p, err := mod.getField(ctx, "Job_output_data_allocated", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint(p)
	return ret, nil
}

func (v *Job) SetOutputDataPosition(_arg uint) error {
	ctx := context.Background()
	arg, err := mod.toUintWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_output_data_position", v.getPtr(), arg)
}

func (v *Job) GetOutputDataPosition() uint {
	ret, err := v.getOutputDataPosition(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getOutputDataPosition(ctx context.Context) (uint, error) {
	var zero uint
	p, err := mod.getField(ctx, "Job_output_data_position", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint(p)
	return ret, nil
}

func (v *Job) SetOutputLangname(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_output_langname", v.getPtr(), arg)
}

func (v *Job) GetOutputLangname() string {
	ret, err := v.getOutputLangname(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getOutputLangname(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Job_output_langname", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Job) SetOutputLang(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_output_lang", v.getPtr(), arg)
}

func (v *Job) GetOutputLang() int64 {
	ret, err := v.getOutputLang(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getOutputLang(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Job_output_lang", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Job) SetRender(_arg *PluginActiveRender) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_render", v.getPtr(), arg)
}

func (v *Job) GetRender() *PluginActiveRender {
	ret, err := v.getRender(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getRender(ctx context.Context) (*PluginActiveRender, error) {
	var zero *PluginActiveRender
	p, err := mod.getField(ctx, "Job_render", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPluginActiveRender(p)
	return ret, nil
}

func (v *Job) SetDevice(_arg *PluginActiveDevice) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_device", v.getPtr(), arg)
}

func (v *Job) GetDevice() *PluginActiveDevice {
	ret, err := v.getDevice(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getDevice(ctx context.Context) (*PluginActiveDevice, error) {
	var zero *PluginActiveDevice
	p, err := mod.getField(ctx, "Job_device", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPluginActiveDevice(p)
	return ret, nil
}

func (v *Job) SetLoadimage(_arg *PluginActiveLoadImage) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_loadimage", v.getPtr(), arg)
}

func (v *Job) GetLoadimage() *PluginActiveLoadImage {
	ret, err := v.getLoadimage(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getLoadimage(ctx context.Context) (*PluginActiveLoadImage, error) {
	var zero *PluginActiveLoadImage
	p, err := mod.getField(ctx, "Job_loadimage", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPluginActiveLoadImage(p)
	return ret, nil
}

func (v *Job) SetCallbacks(_arg *DeviceCallbacks) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_callbacks", v.getPtr(), arg)
}

func (v *Job) GetCallbacks() *DeviceCallbacks {
	ret, err := v.getCallbacks(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getCallbacks(ctx context.Context) (*DeviceCallbacks, error) {
	var zero *DeviceCallbacks
	p, err := mod.getField(ctx, "Job_callbacks", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDeviceCallbacks(p)
	return ret, nil
}

func (v *Job) SetDeviceDpi(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_device_dpi", v.getPtr(), arg)
}

func (v *Job) GetDeviceDpi() *PointFloat {
	ret, err := v.getDeviceDpi(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getDeviceDpi(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_device_dpi", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetDeviceSetsDpi(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_device_sets_dpi", v.getPtr(), arg)
}

func (v *Job) GetDeviceSetsDpi() bool {
	ret, err := v.getDeviceSetsDpi(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getDeviceSetsDpi(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "Job_device_sets_dpi", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *Job) SetDisplay(_arg any) error {
	ctx := context.Background()
	arg, err := mod.toAnyWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_display", v.getPtr(), arg)
}

func (v *Job) GetDisplay() any {
	ret, err := v.getDisplay(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getDisplay(ctx context.Context) (any, error) {
	var zero any
	p, err := mod.getField(ctx, "Job_display", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

func (v *Job) SetScreen(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_screen", v.getPtr(), arg)
}

func (v *Job) GetScreen() int64 {
	ret, err := v.getScreen(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getScreen(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Job_screen", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Job) SetContext(_arg any) error {
	ctx := context.Background()
	arg, err := mod.toAnyWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_context", v.getPtr(), arg)
}

func (v *Job) GetContext() any {
	ret, err := v.getContext(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getContext(ctx context.Context) (any, error) {
	var zero any
	p, err := mod.getField(ctx, "Job_context", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

func (v *Job) SetExternalContext(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_external_context", v.getPtr(), arg)
}

func (v *Job) GetExternalContext() bool {
	ret, err := v.getExternalContext(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getExternalContext(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "Job_external_context", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *Job) SetImagedata(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_imagedata", v.getPtr(), arg)
}

func (v *Job) GetImagedata() string {
	ret, err := v.getImagedata(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getImagedata(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Job_imagedata", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Job) SetFlags(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_flags", v.getPtr(), arg)
}

func (v *Job) GetFlags() int64 {
	ret, err := v.getFlags(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getFlags(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Job_flags", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Job) SetNumLayers(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_num_layers", v.getPtr(), arg)
}

func (v *Job) GetNumLayers() int64 {
	ret, err := v.getNumLayers(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getNumLayers(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Job_num_layers", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Job) SetLayerNum(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_layer_num", v.getPtr(), arg)
}

func (v *Job) GetLayerNum() int64 {
	ret, err := v.getLayerNum(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getLayerNum(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Job_layer_num", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Job) SetPagesArraySize(_arg *Point) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_pages_array_size", v.getPtr(), arg)
}

func (v *Job) GetPagesArraySize() *Point {
	ret, err := v.getPagesArraySize(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getPagesArraySize(ctx context.Context) (*Point, error) {
	var zero *Point
	p, err := mod.getField(ctx, "Job_pages_array_size", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPoint(p)
	return ret, nil
}

func (v *Job) SetPagesArrayFirst(_arg *Point) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_pages_array_first", v.getPtr(), arg)
}

func (v *Job) GetPagesArrayFirst() *Point {
	ret, err := v.getPagesArrayFirst(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getPagesArrayFirst(ctx context.Context) (*Point, error) {
	var zero *Point
	p, err := mod.getField(ctx, "Job_pages_array_first", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPoint(p)
	return ret, nil
}

func (v *Job) SetPagesArrayMajor(_arg *Point) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_pages_array_major", v.getPtr(), arg)
}

func (v *Job) GetPagesArrayMajor() *Point {
	ret, err := v.getPagesArrayMajor(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getPagesArrayMajor(ctx context.Context) (*Point, error) {
	var zero *Point
	p, err := mod.getField(ctx, "Job_pages_array_major", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPoint(p)
	return ret, nil
}

func (v *Job) SetPagesArrayMinor(_arg *Point) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_pages_array_minor", v.getPtr(), arg)
}

func (v *Job) GetPagesArrayMinor() *Point {
	ret, err := v.getPagesArrayMinor(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getPagesArrayMinor(ctx context.Context) (*Point, error) {
	var zero *Point
	p, err := mod.getField(ctx, "Job_pages_array_minor", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPoint(p)
	return ret, nil
}

func (v *Job) SetPagesArrayElem(_arg *Point) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_pages_array_elem", v.getPtr(), arg)
}

func (v *Job) GetPagesArrayElem() *Point {
	ret, err := v.getPagesArrayElem(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getPagesArrayElem(ctx context.Context) (*Point, error) {
	var zero *Point
	p, err := mod.getField(ctx, "Job_pages_array_elem", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPoint(p)
	return ret, nil
}

func (v *Job) SetNumPages(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_num_pages", v.getPtr(), arg)
}

func (v *Job) GetNumPages() int64 {
	ret, err := v.getNumPages(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getNumPages(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Job_num_pages", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Job) SetBb(_arg *BoxFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_bb", v.getPtr(), arg)
}

func (v *Job) GetBb() *BoxFloat {
	ret, err := v.getBb(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getBb(ctx context.Context) (*BoxFloat, error) {
	var zero *BoxFloat
	p, err := mod.getField(ctx, "Job_bb", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newBoxFloat(p)
	return ret, nil
}

func (v *Job) SetPad(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_pad", v.getPtr(), arg)
}

func (v *Job) GetPad() *PointFloat {
	ret, err := v.getPad(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getPad(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_pad", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetClip(_arg *BoxFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_clip", v.getPtr(), arg)
}

func (v *Job) GetClip() *BoxFloat {
	ret, err := v.getClip(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getClip(ctx context.Context) (*BoxFloat, error) {
	var zero *BoxFloat
	p, err := mod.getField(ctx, "Job_clip", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newBoxFloat(p)
	return ret, nil
}

func (v *Job) SetPageBox(_arg *BoxFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_page_box", v.getPtr(), arg)
}

func (v *Job) GetPageBox() *BoxFloat {
	ret, err := v.getPageBox(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getPageBox(ctx context.Context) (*BoxFloat, error) {
	var zero *BoxFloat
	p, err := mod.getField(ctx, "Job_page_box", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newBoxFloat(p)
	return ret, nil
}

func (v *Job) SetPageSize(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_page_size", v.getPtr(), arg)
}

func (v *Job) GetPageSize() *PointFloat {
	ret, err := v.getPageSize(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getPageSize(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_page_size", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetFocus(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_focus", v.getPtr(), arg)
}

func (v *Job) GetFocus() *PointFloat {
	ret, err := v.getFocus(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getFocus(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_focus", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetZoom(_arg float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_zoom", v.getPtr(), arg)
}

func (v *Job) GetZoom() float64 {
	ret, err := v.getZoom(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getZoom(ctx context.Context) (float64, error) {
	var zero float64
	p, err := mod.getField(ctx, "Job_zoom", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Job) SetRotation(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_rotation", v.getPtr(), arg)
}

func (v *Job) GetRotation() int64 {
	ret, err := v.getRotation(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getRotation(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Job_rotation", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Job) SetView(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_view", v.getPtr(), arg)
}

func (v *Job) GetView() *PointFloat {
	ret, err := v.getView(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getView(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_view", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetCanvasBox(_arg *BoxFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_canvas_box", v.getPtr(), arg)
}

func (v *Job) GetCanvasBox() *BoxFloat {
	ret, err := v.getCanvasBox(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getCanvasBox(ctx context.Context) (*BoxFloat, error) {
	var zero *BoxFloat
	p, err := mod.getField(ctx, "Job_canvas_box", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newBoxFloat(p)
	return ret, nil
}

func (v *Job) SetMargin(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_margin", v.getPtr(), arg)
}

func (v *Job) GetMargin() *PointFloat {
	ret, err := v.getMargin(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getMargin(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_margin", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetDpi(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_dpi", v.getPtr(), arg)
}

func (v *Job) GetDpi() *PointFloat {
	ret, err := v.getDpi(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getDpi(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_dpi", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetWidth(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_width", v.getPtr(), arg)
}

func (v *Job) GetWidth() uint64 {
	ret, err := v.getWidth(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getWidth(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "Job_width", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *Job) SetHeight(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_height", v.getPtr(), arg)
}

func (v *Job) GetHeight() uint64 {
	ret, err := v.getHeight(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getHeight(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "Job_height", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *Job) SetPageBoundingBox(_arg *Box) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_page_bounding_box", v.getPtr(), arg)
}

func (v *Job) GetPageBoundingBox() *Box {
	ret, err := v.getPageBoundingBox(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getPageBoundingBox(ctx context.Context) (*Box, error) {
	var zero *Box
	p, err := mod.getField(ctx, "Job_page_bounding_box", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newBox(p)
	return ret, nil
}

func (v *Job) SetBoundingBox(_arg *Box) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_bounding_box", v.getPtr(), arg)
}

func (v *Job) GetBoundingBox() *Box {
	ret, err := v.getBoundingBox(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getBoundingBox(ctx context.Context) (*Box, error) {
	var zero *Box
	p, err := mod.getField(ctx, "Job_bounding_box", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newBox(p)
	return ret, nil
}

func (v *Job) SetScale(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_scale", v.getPtr(), arg)
}

func (v *Job) GetScale() *PointFloat {
	ret, err := v.getScale(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getScale(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_scale", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetTranslation(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_translation", v.getPtr(), arg)
}

func (v *Job) GetTranslation() *PointFloat {
	ret, err := v.getTranslation(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getTranslation(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_translation", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetDevscale(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_devscale", v.getPtr(), arg)
}

func (v *Job) GetDevscale() *PointFloat {
	ret, err := v.getDevscale(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getDevscale(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_devscale", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetFitMode(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_fit_mode", v.getPtr(), arg)
}

func (v *Job) GetFitMode() bool {
	ret, err := v.getFitMode(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getFitMode(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "Job_fit_mode", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *Job) SetNeedsRefresh(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_needs_refresh", v.getPtr(), arg)
}

func (v *Job) GetNeedsRefresh() bool {
	ret, err := v.getNeedsRefresh(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getNeedsRefresh(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "Job_needs_refresh", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *Job) SetClick(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_click", v.getPtr(), arg)
}

func (v *Job) GetClick() bool {
	ret, err := v.getClick(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getClick(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "Job_click", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *Job) SetHasGrown(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_has_grown", v.getPtr(), arg)
}

func (v *Job) GetHasGrown() bool {
	ret, err := v.getHasGrown(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getHasGrown(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "Job_has_grown", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *Job) SetHasBeenRendered(_arg bool) error {
	ctx := context.Background()
	arg, err := mod.toBoolWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_has_been_rendered", v.getPtr(), arg)
}

func (v *Job) GetHasBeenRendered() bool {
	ret, err := v.getHasBeenRendered(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getHasBeenRendered(ctx context.Context) (bool, error) {
	var zero bool
	p, err := mod.getField(ctx, "Job_has_been_rendered", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func (v *Job) SetButton(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_button", v.getPtr(), arg)
}

func (v *Job) GetButton() uint64 {
	ret, err := v.getButton(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getButton(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "Job_button", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *Job) SetPointer(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_pointer", v.getPtr(), arg)
}

func (v *Job) GetPointer() *PointFloat {
	ret, err := v.getPointer(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getPointer(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_pointer", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetOldpointer(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_oldpointer", v.getPtr(), arg)
}

func (v *Job) GetOldpointer() *PointFloat {
	ret, err := v.getOldpointer(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getOldpointer(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Job_oldpointer", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Job) SetCurrentObj(_arg any) error {
	ctx := context.Background()
	arg, err := mod.toAnyWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_current_obj", v.getPtr(), arg)
}

func (v *Job) GetCurrentObj() any {
	ret, err := v.getCurrentObj(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getCurrentObj(ctx context.Context) (any, error) {
	var zero any
	p, err := mod.getField(ctx, "Job_current_obj", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

func (v *Job) SetSelectedObj(_arg any) error {
	ctx := context.Background()
	arg, err := mod.toAnyWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_selected_obj", v.getPtr(), arg)
}

func (v *Job) GetSelectedObj() any {
	ret, err := v.getSelectedObj(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getSelectedObj(ctx context.Context) (any, error) {
	var zero any
	p, err := mod.getField(ctx, "Job_selected_obj", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

func (v *Job) SetActiveTooltip(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_active_tooltip", v.getPtr(), arg)
}

func (v *Job) GetActiveTooltip() string {
	ret, err := v.getActiveTooltip(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getActiveTooltip(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Job_active_tooltip", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Job) SetSelectedHref(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Job_selected_href", v.getPtr(), arg)
}

func (v *Job) GetSelectedHref() string {
	ret, err := v.getSelectedHref(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Job) getSelectedHref(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Job_selected_href", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

type Point struct {
	ptr uint64
}

func NewPoint(ctx context.Context) (*Point, error) {
	o, err := mod.newObject(ctx, "Point")
	if err != nil {
		return nil, err
	}
	return newPoint(o), nil
}

func newPoint(ptr uint64) *Point {
	if ptr == 0 {
		return nil
	}
	return &Point{ptr: ptr}
}

func (v *Point) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newPointSlice(v []uint64) []*Point {
	ret := make([]*Point, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newPoint(vv))
	}
	return ret
}
func (v *Point) SetX(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Point_x", v.getPtr(), arg)
}

func (v *Point) GetX() int64 {
	ret, err := v.getX(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Point) getX(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Point_x", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Point) SetY(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Point_y", v.getPtr(), arg)
}

func (v *Point) GetY() int64 {
	ret, err := v.getY(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Point) getY(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Point_y", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

type BoxFloat struct {
	ptr uint64
}

func NewBoxFloat(ctx context.Context) (*BoxFloat, error) {
	o, err := mod.newObject(ctx, "BoxFloat")
	if err != nil {
		return nil, err
	}
	return newBoxFloat(o), nil
}

func newBoxFloat(ptr uint64) *BoxFloat {
	if ptr == 0 {
		return nil
	}
	return &BoxFloat{ptr: ptr}
}

func (v *BoxFloat) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newBoxFloatSlice(v []uint64) []*BoxFloat {
	ret := make([]*BoxFloat, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newBoxFloat(vv))
	}
	return ret
}
func (v *BoxFloat) SetLl(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "BoxFloat_ll", v.getPtr(), arg)
}

func (v *BoxFloat) GetLl() *PointFloat {
	ret, err := v.getLl(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *BoxFloat) getLl(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "BoxFloat_ll", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *BoxFloat) SetUr(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "BoxFloat_ur", v.getPtr(), arg)
}

func (v *BoxFloat) GetUr() *PointFloat {
	ret, err := v.getUr(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *BoxFloat) getUr(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "BoxFloat_ur", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

type Box struct {
	ptr uint64
}

func NewBox(ctx context.Context) (*Box, error) {
	o, err := mod.newObject(ctx, "Box")
	if err != nil {
		return nil, err
	}
	return newBox(o), nil
}

func newBox(ptr uint64) *Box {
	if ptr == 0 {
		return nil
	}
	return &Box{ptr: ptr}
}

func (v *Box) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newBoxSlice(v []uint64) []*Box {
	ret := make([]*Box, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newBox(vv))
	}
	return ret
}
func (v *Box) SetLl(_arg *Point) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Box_ll", v.getPtr(), arg)
}

func (v *Box) GetLl() *Point {
	ret, err := v.getLl(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Box) getLl(ctx context.Context) (*Point, error) {
	var zero *Point
	p, err := mod.getField(ctx, "Box_ll", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPoint(p)
	return ret, nil
}

func (v *Box) SetUr(_arg *Point) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Box_ur", v.getPtr(), arg)
}

func (v *Box) GetUr() *Point {
	ret, err := v.getUr(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Box) getUr(ctx context.Context) (*Point, error) {
	var zero *Point
	p, err := mod.getField(ctx, "Box_ur", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPoint(p)
	return ret, nil
}

type Color struct {
	ptr uint64
}

func NewColor(ctx context.Context) (*Color, error) {
	o, err := mod.newObject(ctx, "Color")
	if err != nil {
		return nil, err
	}
	return newColor(o), nil
}

func newColor(ptr uint64) *Color {
	if ptr == 0 {
		return nil
	}
	return &Color{ptr: ptr}
}

func (v *Color) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newColorSlice(v []uint64) []*Color {
	ret := make([]*Color, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newColor(vv))
	}
	return ret
}
func (v *Color) SetRgbaDouble(_arg []float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Color_rgba_double", v.getPtr(), arg)
}

func (v *Color) GetRgbaDouble() []float64 {
	ret, err := v.getRgbaDouble(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Color) getRgbaDouble(ctx context.Context) ([]float64, error) {
	var zero []float64
	p, err := mod.getField(ctx, "Color_rgba_double", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64Slice(ctx, slice)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Color) SetHsva(_arg []float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Color_hsva", v.getPtr(), arg)
}

func (v *Color) GetHsva() []float64 {
	ret, err := v.getHsva(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Color) getHsva(ctx context.Context) ([]float64, error) {
	var zero []float64
	p, err := mod.getField(ctx, "Color_hsva", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64Slice(ctx, slice)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Color) SetRgbaUint(_arg []uint) error {
	ctx := context.Background()
	arg, err := mod.toUintArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Color_rgba_uint", v.getPtr(), arg)
}

func (v *Color) GetRgbaUint() []uint {
	ret, err := v.getRgbaUint(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Color) getRgbaUint(ctx context.Context) ([]uint, error) {
	var zero []uint
	p, err := mod.getField(ctx, "Color_rgba_uint", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := mod.toUintSlice(slice)
	return ret, nil
}

func (v *Color) SetRgbaInt(_arg []int) error {
	ctx := context.Background()
	arg, err := mod.toIntArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Color_rgba_int", v.getPtr(), arg)
}

func (v *Color) GetRgbaInt() []int {
	ret, err := v.getRgbaInt(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Color) getRgbaInt(ctx context.Context) ([]int, error) {
	var zero []int
	p, err := mod.getField(ctx, "Color_rgba_int", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := mod.toIntSlice(slice)
	return ret, nil
}

func (v *Color) SetString(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Color_string", v.getPtr(), arg)
}

func (v *Color) GetString() string {
	ret, err := v.getString(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Color) getString(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Color_string", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Color) SetIndex(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Color_index", v.getPtr(), arg)
}

func (v *Color) GetIndex() int64 {
	ret, err := v.getIndex(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Color) getIndex(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Color_index", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *Color) SetType(_arg ColorType) error {
	ctx := context.Background()
	arg, err := mod.toIntWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Color_type", v.getPtr(), arg)
}

func (v *Color) GetType() ColorType {
	ret, err := v.getType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Color) getType(ctx context.Context) (ColorType, error) {
	var zero ColorType
	p, err := mod.getField(ctx, "Color_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := ColorType(p)
	return ret, nil
}

type PointFloat struct {
	ptr uint64
}

func NewPointFloat(ctx context.Context) (*PointFloat, error) {
	o, err := mod.newObject(ctx, "PointFloat")
	if err != nil {
		return nil, err
	}
	return newPointFloat(o), nil
}

func newPointFloat(ptr uint64) *PointFloat {
	if ptr == 0 {
		return nil
	}
	return &PointFloat{ptr: ptr}
}

func (v *PointFloat) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newPointFloatSlice(v []uint64) []*PointFloat {
	ret := make([]*PointFloat, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newPointFloat(vv))
	}
	return ret
}
func (v *PointFloat) SetX(_arg float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PointFloat_x", v.getPtr(), arg)
}

func (v *PointFloat) GetX() float64 {
	ret, err := v.getX(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PointFloat) getX(ctx context.Context) (float64, error) {
	var zero float64
	p, err := mod.getField(ctx, "PointFloat_x", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PointFloat) SetY(_arg float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PointFloat_y", v.getPtr(), arg)
}

func (v *PointFloat) GetY() float64 {
	ret, err := v.getY(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PointFloat) getY(ctx context.Context) (float64, error) {
	var zero float64
	p, err := mod.getField(ctx, "PointFloat_y", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

type PluginActiveDevice struct {
	ptr uint64
}

func NewPluginActiveDevice(ctx context.Context) (*PluginActiveDevice, error) {
	o, err := mod.newObject(ctx, "PluginActiveDevice")
	if err != nil {
		return nil, err
	}
	return newPluginActiveDevice(o), nil
}

func newPluginActiveDevice(ptr uint64) *PluginActiveDevice {
	if ptr == 0 {
		return nil
	}
	return &PluginActiveDevice{ptr: ptr}
}

func (v *PluginActiveDevice) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newPluginActiveDeviceSlice(v []uint64) []*PluginActiveDevice {
	ret := make([]*PluginActiveDevice, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newPluginActiveDevice(vv))
	}
	return ret
}
func (v *PluginActiveDevice) SetEngine(_arg *DeviceEngine) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginActiveDevice_engine", v.getPtr(), arg)
}

func (v *PluginActiveDevice) GetEngine() *DeviceEngine {
	ret, err := v.getEngine(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginActiveDevice) getEngine(ctx context.Context) (*DeviceEngine, error) {
	var zero *DeviceEngine
	p, err := mod.getField(ctx, "PluginActiveDevice_engine", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDeviceEngine(p)
	return ret, nil
}

func (v *PluginActiveDevice) SetId(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginActiveDevice_id", v.getPtr(), arg)
}

func (v *PluginActiveDevice) GetId() int64 {
	ret, err := v.getId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginActiveDevice) getId(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "PluginActiveDevice_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *PluginActiveDevice) SetFeatures(_arg *DeviceFeatures) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginActiveDevice_features", v.getPtr(), arg)
}

func (v *PluginActiveDevice) GetFeatures() *DeviceFeatures {
	ret, err := v.getFeatures(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginActiveDevice) getFeatures(ctx context.Context) (*DeviceFeatures, error) {
	var zero *DeviceFeatures
	p, err := mod.getField(ctx, "PluginActiveDevice_features", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDeviceFeatures(p)
	return ret, nil
}

func (v *PluginActiveDevice) SetType(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginActiveDevice_type", v.getPtr(), arg)
}

func (v *PluginActiveDevice) GetType() string {
	ret, err := v.getType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginActiveDevice) getType(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PluginActiveDevice_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

type PluginActiveRender struct {
	ptr uint64
}

func NewPluginActiveRender(ctx context.Context) (*PluginActiveRender, error) {
	o, err := mod.newObject(ctx, "PluginActiveRender")
	if err != nil {
		return nil, err
	}
	return newPluginActiveRender(o), nil
}

func newPluginActiveRender(ptr uint64) *PluginActiveRender {
	if ptr == 0 {
		return nil
	}
	return &PluginActiveRender{ptr: ptr}
}

func (v *PluginActiveRender) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newPluginActiveRenderSlice(v []uint64) []*PluginActiveRender {
	ret := make([]*PluginActiveRender, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newPluginActiveRender(vv))
	}
	return ret
}
func (v *PluginActiveRender) SetEngine(_arg *RenderEngine) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginActiveRender_engine", v.getPtr(), arg)
}

func (v *PluginActiveRender) GetEngine() *RenderEngine {
	ret, err := v.getEngine(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginActiveRender) getEngine(ctx context.Context) (*RenderEngine, error) {
	var zero *RenderEngine
	p, err := mod.getField(ctx, "PluginActiveRender_engine", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newRenderEngine(p)
	return ret, nil
}

func (v *PluginActiveRender) SetId(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginActiveRender_id", v.getPtr(), arg)
}

func (v *PluginActiveRender) GetId() int64 {
	ret, err := v.getId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginActiveRender) getId(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "PluginActiveRender_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *PluginActiveRender) SetFeatures(_arg *RenderFeatures) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginActiveRender_features", v.getPtr(), arg)
}

func (v *PluginActiveRender) GetFeatures() *RenderFeatures {
	ret, err := v.getFeatures(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginActiveRender) getFeatures(ctx context.Context) (*RenderFeatures, error) {
	var zero *RenderFeatures
	p, err := mod.getField(ctx, "PluginActiveRender_features", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newRenderFeatures(p)
	return ret, nil
}

func (v *PluginActiveRender) SetType(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginActiveRender_type", v.getPtr(), arg)
}

func (v *PluginActiveRender) GetType() string {
	ret, err := v.getType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginActiveRender) getType(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PluginActiveRender_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

type DeviceEngine struct {
	ptr uint64
}

func NewDeviceEngine(ctx context.Context) (*DeviceEngine, error) {
	o, err := mod.newObject(ctx, "DeviceEngine")
	if err != nil {
		return nil, err
	}
	return newDeviceEngine(o), nil
}

func newDeviceEngine(ptr uint64) *DeviceEngine {
	if ptr == 0 {
		return nil
	}
	return &DeviceEngine{ptr: ptr}
}

func (v *DeviceEngine) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newDeviceEngineSlice(v []uint64) []*DeviceEngine {
	ret := make([]*DeviceEngine, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newDeviceEngine(vv))
	}
	return ret
}
func (v *DeviceEngine) SetInitialize(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.DeviceEngine_Initialize == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceEngine_Initialize before")
	}
	mod.callbackFuncMap.DeviceEngine_Initialize[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceEngine_initialize", v.getPtr())
}

func (v *DeviceEngine) SetFormat(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.DeviceEngine_Format == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceEngine_Format before")
	}
	mod.callbackFuncMap.DeviceEngine_Format[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceEngine_format", v.getPtr())
}

func (v *DeviceEngine) SetFinalize(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.DeviceEngine_Finalize == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_DeviceEngine_Finalize before")
	}
	mod.callbackFuncMap.DeviceEngine_Finalize[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "DeviceEngine_finalize", v.getPtr())
}

type PostscriptAlias struct {
	ptr uint64
}

func NewPostscriptAlias(ctx context.Context) (*PostscriptAlias, error) {
	o, err := mod.newObject(ctx, "PostscriptAlias")
	if err != nil {
		return nil, err
	}
	return newPostscriptAlias(o), nil
}

func newPostscriptAlias(ptr uint64) *PostscriptAlias {
	if ptr == 0 {
		return nil
	}
	return &PostscriptAlias{ptr: ptr}
}

func (v *PostscriptAlias) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newPostscriptAliasSlice(v []uint64) []*PostscriptAlias {
	ret := make([]*PostscriptAlias, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newPostscriptAlias(vv))
	}
	return ret
}
func (v *PostscriptAlias) SetName(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PostscriptAlias_name", v.getPtr(), arg)
}

func (v *PostscriptAlias) GetName() string {
	ret, err := v.getName(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PostscriptAlias) getName(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PostscriptAlias_name", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PostscriptAlias) SetFamily(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PostscriptAlias_family", v.getPtr(), arg)
}

func (v *PostscriptAlias) GetFamily() string {
	ret, err := v.getFamily(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PostscriptAlias) getFamily(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PostscriptAlias_family", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PostscriptAlias) SetWeight(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PostscriptAlias_weight", v.getPtr(), arg)
}

func (v *PostscriptAlias) GetWeight() string {
	ret, err := v.getWeight(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PostscriptAlias) getWeight(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PostscriptAlias_weight", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PostscriptAlias) SetStretch(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PostscriptAlias_stretch", v.getPtr(), arg)
}

func (v *PostscriptAlias) GetStretch() string {
	ret, err := v.getStretch(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PostscriptAlias) getStretch(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PostscriptAlias_stretch", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PostscriptAlias) SetStyle(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PostscriptAlias_style", v.getPtr(), arg)
}

func (v *PostscriptAlias) GetStyle() string {
	ret, err := v.getStyle(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PostscriptAlias) getStyle(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PostscriptAlias_style", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PostscriptAlias) SetXfigCode(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PostscriptAlias_xfig_code", v.getPtr(), arg)
}

func (v *PostscriptAlias) GetXfigCode() int64 {
	ret, err := v.getXfigCode(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PostscriptAlias) getXfigCode(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "PostscriptAlias_xfig_code", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *PostscriptAlias) SetSvgFontFamily(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PostscriptAlias_svg_font_family", v.getPtr(), arg)
}

func (v *PostscriptAlias) GetSvgFontFamily() string {
	ret, err := v.getSvgFontFamily(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PostscriptAlias) getSvgFontFamily(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PostscriptAlias_svg_font_family", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PostscriptAlias) SetSvgFontWeight(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PostscriptAlias_svg_font_weight", v.getPtr(), arg)
}

func (v *PostscriptAlias) GetSvgFontWeight() string {
	ret, err := v.getSvgFontWeight(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PostscriptAlias) getSvgFontWeight(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PostscriptAlias_svg_font_weight", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PostscriptAlias) SetSvgFontStyle(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PostscriptAlias_svg_font_style", v.getPtr(), arg)
}

func (v *PostscriptAlias) GetSvgFontStyle() string {
	ret, err := v.getSvgFontStyle(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PostscriptAlias) getSvgFontStyle(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PostscriptAlias_svg_font_style", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

type TextFont struct {
	ptr uint64
}

func NewTextFont(ctx context.Context) (*TextFont, error) {
	o, err := mod.newObject(ctx, "TextFont")
	if err != nil {
		return nil, err
	}
	return newTextFont(o), nil
}

func newTextFont(ptr uint64) *TextFont {
	if ptr == 0 {
		return nil
	}
	return &TextFont{ptr: ptr}
}

func (v *TextFont) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newTextFontSlice(v []uint64) []*TextFont {
	ret := make([]*TextFont, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newTextFont(vv))
	}
	return ret
}
func (v *TextFont) SetName(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "TextFont_name", v.getPtr(), arg)
}

func (v *TextFont) GetName() string {
	ret, err := v.getName(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *TextFont) getName(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "TextFont_name", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *TextFont) SetColor(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "TextFont_color", v.getPtr(), arg)
}

func (v *TextFont) GetColor() string {
	ret, err := v.getColor(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *TextFont) getColor(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "TextFont_color", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *TextFont) SetPostscriptAlias(_arg *PostscriptAlias) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "TextFont_postscript_alias", v.getPtr(), arg)
}

func (v *TextFont) GetPostscriptAlias() *PostscriptAlias {
	ret, err := v.getPostscriptAlias(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *TextFont) getPostscriptAlias(ctx context.Context) (*PostscriptAlias, error) {
	var zero *PostscriptAlias
	p, err := mod.getField(ctx, "TextFont_postscript_alias", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPostscriptAlias(p)
	return ret, nil
}

func (v *TextFont) SetSize(_arg float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "TextFont_size", v.getPtr(), arg)
}

func (v *TextFont) GetSize() float64 {
	ret, err := v.getSize(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *TextFont) getSize(ctx context.Context) (float64, error) {
	var zero float64
	p, err := mod.getField(ctx, "TextFont_size", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *TextFont) SetFlags(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "TextFont_flags", v.getPtr(), arg)
}

func (v *TextFont) GetFlags() uint64 {
	ret, err := v.getFlags(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *TextFont) getFlags(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "TextFont_flags", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

func (v *TextFont) SetCount(_arg uint64) error {
	ctx := context.Background()
	arg, err := mod.toUint64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "TextFont_count", v.getPtr(), arg)
}

func (v *TextFont) GetCount() uint64 {
	ret, err := v.getCount(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *TextFont) getCount(ctx context.Context) (uint64, error) {
	var zero uint64
	p, err := mod.getField(ctx, "TextFont_count", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toUint64(p)
	return ret, nil
}

type Textspan struct {
	ptr uint64
}

func NewTextspan(ctx context.Context) (*Textspan, error) {
	o, err := mod.newObject(ctx, "Textspan")
	if err != nil {
		return nil, err
	}
	return newTextspan(o), nil
}

func newTextspan(ptr uint64) *Textspan {
	if ptr == 0 {
		return nil
	}
	return &Textspan{ptr: ptr}
}

func (v *Textspan) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newTextspanSlice(v []uint64) []*Textspan {
	ret := make([]*Textspan, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newTextspan(vv))
	}
	return ret
}
func (v *Textspan) SetStr(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Textspan_str", v.getPtr(), arg)
}

func (v *Textspan) GetStr() string {
	ret, err := v.getStr(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Textspan) getStr(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "Textspan_str", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Textspan) SetFont(_arg *TextFont) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Textspan_font", v.getPtr(), arg)
}

func (v *Textspan) GetFont() *TextFont {
	ret, err := v.getFont(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Textspan) getFont(ctx context.Context) (*TextFont, error) {
	var zero *TextFont
	p, err := mod.getField(ctx, "Textspan_font", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newTextFont(p)
	return ret, nil
}

func (v *Textspan) SetYOffsetLayout(_arg float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Textspan_y_offset_layout", v.getPtr(), arg)
}

func (v *Textspan) GetYOffsetLayout() float64 {
	ret, err := v.getYOffsetLayout(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Textspan) getYOffsetLayout(ctx context.Context) (float64, error) {
	var zero float64
	p, err := mod.getField(ctx, "Textspan_y_offset_layout", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Textspan) SetYOffsetCenterLine(_arg float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Textspan_y_offset_center_line", v.getPtr(), arg)
}

func (v *Textspan) GetYOffsetCenterLine() float64 {
	ret, err := v.getYOffsetCenterLine(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Textspan) getYOffsetCenterLine(ctx context.Context) (float64, error) {
	var zero float64
	p, err := mod.getField(ctx, "Textspan_y_offset_center_line", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Textspan) SetSize(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Textspan_size", v.getPtr(), arg)
}

func (v *Textspan) GetSize() *PointFloat {
	ret, err := v.getSize(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Textspan) getSize(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "Textspan_size", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *Textspan) SetJust(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "Textspan_just", v.getPtr(), arg)
}

func (v *Textspan) GetJust() int64 {
	ret, err := v.getJust(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *Textspan) getJust(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "Textspan_just", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

type RenderEngine struct {
	ptr uint64
}

func NewRenderEngine(ctx context.Context) (*RenderEngine, error) {
	o, err := mod.newObject(ctx, "RenderEngine")
	if err != nil {
		return nil, err
	}
	return newRenderEngine(o), nil
}

func newRenderEngine(ptr uint64) *RenderEngine {
	if ptr == 0 {
		return nil
	}
	return &RenderEngine{ptr: ptr}
}

func (v *RenderEngine) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newRenderEngineSlice(v []uint64) []*RenderEngine {
	ret := make([]*RenderEngine, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newRenderEngine(vv))
	}
	return ret
}
func (v *RenderEngine) SetBeginJob(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_BeginJob == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_BeginJob before")
	}
	mod.callbackFuncMap.RenderEngine_BeginJob[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_begin_job", v.getPtr())
}

func (v *RenderEngine) SetEndJob(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_EndJob == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_EndJob before")
	}
	mod.callbackFuncMap.RenderEngine_EndJob[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_end_job", v.getPtr())
}

func (v *RenderEngine) SetBeginGraph(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_BeginGraph == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_BeginGraph before")
	}
	mod.callbackFuncMap.RenderEngine_BeginGraph[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_begin_graph", v.getPtr())
}

func (v *RenderEngine) SetEndGraph(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_EndGraph == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_EndGraph before")
	}
	mod.callbackFuncMap.RenderEngine_EndGraph[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_end_graph", v.getPtr())
}

func (v *RenderEngine) SetBeginLayer(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, string, int, int) error]) error {
	if mod.lookupFuncMap.RenderEngine_BeginLayer == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_BeginLayer before")
	}
	mod.callbackFuncMap.RenderEngine_BeginLayer[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_begin_layer", v.getPtr())
}

func (v *RenderEngine) SetEndLayer(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_EndLayer == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_EndLayer before")
	}
	mod.callbackFuncMap.RenderEngine_EndLayer[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_end_layer", v.getPtr())
}

func (v *RenderEngine) SetBeginPage(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_BeginPage == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_BeginPage before")
	}
	mod.callbackFuncMap.RenderEngine_BeginPage[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_begin_page", v.getPtr())
}

func (v *RenderEngine) SetEndPage(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_EndPage == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_EndPage before")
	}
	mod.callbackFuncMap.RenderEngine_EndPage[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_end_page", v.getPtr())
}

func (v *RenderEngine) SetBeginCluster(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_BeginCluster == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_BeginCluster before")
	}
	mod.callbackFuncMap.RenderEngine_BeginCluster[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_begin_cluster", v.getPtr())
}

func (v *RenderEngine) SetEndCluster(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_EndCluster == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_EndCluster before")
	}
	mod.callbackFuncMap.RenderEngine_EndCluster[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_end_cluster", v.getPtr())
}

func (v *RenderEngine) SetBeginNodes(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_BeginNodes == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_BeginNodes before")
	}
	mod.callbackFuncMap.RenderEngine_BeginNodes[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_begin_nodes", v.getPtr())
}

func (v *RenderEngine) SetEndNodes(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_EndNodes == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_EndNodes before")
	}
	mod.callbackFuncMap.RenderEngine_EndNodes[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_end_nodes", v.getPtr())
}

func (v *RenderEngine) SetBeginEdges(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_BeginEdges == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_BeginEdges before")
	}
	mod.callbackFuncMap.RenderEngine_BeginEdges[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_begin_edges", v.getPtr())
}

func (v *RenderEngine) SetEndEdges(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_EndEdges == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_EndEdges before")
	}
	mod.callbackFuncMap.RenderEngine_EndEdges[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_end_edges", v.getPtr())
}

func (v *RenderEngine) SetBeginNode(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_BeginNode == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_BeginNode before")
	}
	mod.callbackFuncMap.RenderEngine_BeginNode[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_begin_node", v.getPtr())
}

func (v *RenderEngine) SetEndNode(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_EndNode == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_EndNode before")
	}
	mod.callbackFuncMap.RenderEngine_EndNode[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_end_node", v.getPtr())
}

func (v *RenderEngine) SetBeginEdge(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_BeginEdge == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_BeginEdge before")
	}
	mod.callbackFuncMap.RenderEngine_BeginEdge[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_begin_edge", v.getPtr())
}

func (v *RenderEngine) SetEndEdge(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_EndEdge == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_EndEdge before")
	}
	mod.callbackFuncMap.RenderEngine_EndEdge[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_end_edge", v.getPtr())
}

func (v *RenderEngine) SetBeginAnchor(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, string, string, string, string) error]) error {
	if mod.lookupFuncMap.RenderEngine_BeginAnchor == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_BeginAnchor before")
	}
	mod.callbackFuncMap.RenderEngine_BeginAnchor[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_begin_anchor", v.getPtr())
}

func (v *RenderEngine) SetEndAnchor(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_EndAnchor == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_EndAnchor before")
	}
	mod.callbackFuncMap.RenderEngine_EndAnchor[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_end_anchor", v.getPtr())
}

func (v *RenderEngine) SetBeginLabel(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, LabelType) error]) error {
	if mod.lookupFuncMap.RenderEngine_BeginLabel == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_BeginLabel before")
	}
	mod.callbackFuncMap.RenderEngine_BeginLabel[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_begin_label", v.getPtr())
}

func (v *RenderEngine) SetEndLabel(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job) error]) error {
	if mod.lookupFuncMap.RenderEngine_EndLabel == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_EndLabel before")
	}
	mod.callbackFuncMap.RenderEngine_EndLabel[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_end_label", v.getPtr())
}

func (v *RenderEngine) SetTextspan(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, *PointFloat, *Textspan) error]) error {
	if mod.lookupFuncMap.RenderEngine_Textspan == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_Textspan before")
	}
	mod.callbackFuncMap.RenderEngine_Textspan[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_textspan", v.getPtr())
}

func (v *RenderEngine) SetResolveColor(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, *Color) error]) error {
	if mod.lookupFuncMap.RenderEngine_ResolveColor == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_ResolveColor before")
	}
	mod.callbackFuncMap.RenderEngine_ResolveColor[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_resolve_color", v.getPtr())
}

func (v *RenderEngine) SetEllipse(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, []*PointFloat, int) error]) error {
	if mod.lookupFuncMap.RenderEngine_Ellipse == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_Ellipse before")
	}
	mod.callbackFuncMap.RenderEngine_Ellipse[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_ellipse", v.getPtr())
}

func (v *RenderEngine) SetPolygon(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, []*PointFloat, uint32, int) error]) error {
	if mod.lookupFuncMap.RenderEngine_Polygon == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_Polygon before")
	}
	mod.callbackFuncMap.RenderEngine_Polygon[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_polygon", v.getPtr())
}

func (v *RenderEngine) SetBeziercurve(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, []*PointFloat, uint32, int) error]) error {
	if mod.lookupFuncMap.RenderEngine_Beziercurve == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_Beziercurve before")
	}
	mod.callbackFuncMap.RenderEngine_Beziercurve[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_beziercurve", v.getPtr())
}

func (v *RenderEngine) SetPolyline(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, []*PointFloat, uint32) error]) error {
	if mod.lookupFuncMap.RenderEngine_Polyline == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_Polyline before")
	}
	mod.callbackFuncMap.RenderEngine_Polyline[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_polyline", v.getPtr())
}

func (v *RenderEngine) SetComment(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, string) error]) error {
	if mod.lookupFuncMap.RenderEngine_Comment == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_Comment before")
	}
	mod.callbackFuncMap.RenderEngine_Comment[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_comment", v.getPtr())
}

func (v *RenderEngine) SetLibraryShape(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, string, []*PointFloat, uint32, int) error]) error {
	if mod.lookupFuncMap.RenderEngine_LibraryShape == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_RenderEngine_LibraryShape before")
	}
	mod.callbackFuncMap.RenderEngine_LibraryShape[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "RenderEngine_library_shape", v.getPtr())
}

type FormatterEngine struct {
	ptr uint64
}

func newFormatterEngine(ptr uint64) *FormatterEngine {
	if ptr == 0 {
		return nil
	}
	return &FormatterEngine{ptr: ptr}
}

func (v *FormatterEngine) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newFormatterEngineSlice(v []uint64) []*FormatterEngine {
	ret := make([]*FormatterEngine, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newFormatterEngine(vv))
	}
	return ret
}

type LayoutEngine struct {
	ptr uint64
}

func NewLayoutEngine(ctx context.Context) (*LayoutEngine, error) {
	o, err := mod.newObject(ctx, "LayoutEngine")
	if err != nil {
		return nil, err
	}
	return newLayoutEngine(o), nil
}

func newLayoutEngine(ptr uint64) *LayoutEngine {
	if ptr == 0 {
		return nil
	}
	return &LayoutEngine{ptr: ptr}
}

func (v *LayoutEngine) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newLayoutEngineSlice(v []uint64) []*LayoutEngine {
	ret := make([]*LayoutEngine, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newLayoutEngine(vv))
	}
	return ret
}
func (v *LayoutEngine) SetLayout(ctx context.Context, arg *CallbackFunc[func(context.Context, *Graph) error]) error {
	if mod.lookupFuncMap.LayoutEngine_Layout == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_LayoutEngine_Layout before")
	}
	mod.callbackFuncMap.LayoutEngine_Layout[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "LayoutEngine_layout", v.getPtr())
}

func (v *LayoutEngine) SetCleanup(ctx context.Context, arg *CallbackFunc[func(context.Context, *Graph) error]) error {
	if mod.lookupFuncMap.LayoutEngine_Cleanup == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_LayoutEngine_Cleanup before")
	}
	mod.callbackFuncMap.LayoutEngine_Cleanup[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "LayoutEngine_cleanup", v.getPtr())
}

type TextLayoutEngine struct {
	ptr uint64
}

func NewTextLayoutEngine(ctx context.Context) (*TextLayoutEngine, error) {
	o, err := mod.newObject(ctx, "TextLayoutEngine")
	if err != nil {
		return nil, err
	}
	return newTextLayoutEngine(o), nil
}

func newTextLayoutEngine(ptr uint64) *TextLayoutEngine {
	if ptr == 0 {
		return nil
	}
	return &TextLayoutEngine{ptr: ptr}
}

func (v *TextLayoutEngine) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newTextLayoutEngineSlice(v []uint64) []*TextLayoutEngine {
	ret := make([]*TextLayoutEngine, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newTextLayoutEngine(vv))
	}
	return ret
}
func (v *TextLayoutEngine) SetTextlayout(ctx context.Context, arg *CallbackFunc[func(context.Context, *Textspan, []string) (bool, error)]) error {
	if mod.lookupFuncMap.TextLayoutEngine_TextLayout == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_TextLayoutEngine_TextLayout before")
	}
	mod.callbackFuncMap.TextLayoutEngine_TextLayout[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "TextLayoutEngine_textlayout", v.getPtr())
}

type LoadImageEngine struct {
	ptr uint64
}

func NewLoadImageEngine(ctx context.Context) (*LoadImageEngine, error) {
	o, err := mod.newObject(ctx, "LoadImageEngine")
	if err != nil {
		return nil, err
	}
	return newLoadImageEngine(o), nil
}

func newLoadImageEngine(ptr uint64) *LoadImageEngine {
	if ptr == 0 {
		return nil
	}
	return &LoadImageEngine{ptr: ptr}
}

func (v *LoadImageEngine) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newLoadImageEngineSlice(v []uint64) []*LoadImageEngine {
	ret := make([]*LoadImageEngine, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newLoadImageEngine(vv))
	}
	return ret
}
func (v *LoadImageEngine) SetLoadImage(ctx context.Context, arg *CallbackFunc[func(context.Context, *Job, *UserShape, *BoxFloat, bool) error]) error {
	if mod.lookupFuncMap.LoadImageEngine_LoadImage == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_LoadImageEngine_LoadImage before")
	}
	mod.callbackFuncMap.LoadImageEngine_LoadImage[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "LoadImageEngine_load_image", v.getPtr())
}

type Engine struct {
	ptr uint64
}

func NewEngine(ctx context.Context) (*Engine, error) {
	o, err := mod.newObject(ctx, "Engine")
	if err != nil {
		return nil, err
	}
	return newEngine(o), nil
}

func newEngine(ptr uint64) *Engine {
	if ptr == 0 {
		return nil
	}
	return &Engine{ptr: ptr}
}

func (v *Engine) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newEngineSlice(v []uint64) []*Engine {
	ret := make([]*Engine, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newEngine(vv))
	}
	return ret
}

type LayoutFeatures struct {
	ptr uint64
}

func NewLayoutFeatures(ctx context.Context) (*LayoutFeatures, error) {
	o, err := mod.newObject(ctx, "LayoutFeatures")
	if err != nil {
		return nil, err
	}
	return newLayoutFeatures(o), nil
}

func newLayoutFeatures(ptr uint64) *LayoutFeatures {
	if ptr == 0 {
		return nil
	}
	return &LayoutFeatures{ptr: ptr}
}

func (v *LayoutFeatures) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newLayoutFeaturesSlice(v []uint64) []*LayoutFeatures {
	ret := make([]*LayoutFeatures, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newLayoutFeatures(vv))
	}
	return ret
}
func (v *LayoutFeatures) SetFlags(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "LayoutFeatures_flags", v.getPtr(), arg)
}

func (v *LayoutFeatures) GetFlags() int64 {
	ret, err := v.getFlags(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *LayoutFeatures) getFlags(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "LayoutFeatures_flags", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

type DeviceFeatures struct {
	ptr uint64
}

func NewDeviceFeatures(ctx context.Context) (*DeviceFeatures, error) {
	o, err := mod.newObject(ctx, "DeviceFeatures")
	if err != nil {
		return nil, err
	}
	return newDeviceFeatures(o), nil
}

func newDeviceFeatures(ptr uint64) *DeviceFeatures {
	if ptr == 0 {
		return nil
	}
	return &DeviceFeatures{ptr: ptr}
}

func (v *DeviceFeatures) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newDeviceFeaturesSlice(v []uint64) []*DeviceFeatures {
	ret := make([]*DeviceFeatures, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newDeviceFeatures(vv))
	}
	return ret
}
func (v *DeviceFeatures) SetFlags(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DeviceFeatures_flags", v.getPtr(), arg)
}

func (v *DeviceFeatures) GetFlags() int64 {
	ret, err := v.getFlags(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DeviceFeatures) getFlags(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "DeviceFeatures_flags", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *DeviceFeatures) SetDefaultMargin(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DeviceFeatures_default_margin", v.getPtr(), arg)
}

func (v *DeviceFeatures) GetDefaultMargin() *PointFloat {
	ret, err := v.getDefaultMargin(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DeviceFeatures) getDefaultMargin(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "DeviceFeatures_default_margin", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *DeviceFeatures) SetDefaultPagesize(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DeviceFeatures_default_pagesize", v.getPtr(), arg)
}

func (v *DeviceFeatures) GetDefaultPagesize() *PointFloat {
	ret, err := v.getDefaultPagesize(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DeviceFeatures) getDefaultPagesize(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "DeviceFeatures_default_pagesize", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

func (v *DeviceFeatures) SetDefaultDpi(_arg *PointFloat) error {
	ctx := context.Background()
	arg, err := mod.toObjectWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "DeviceFeatures_default_dpi", v.getPtr(), arg)
}

func (v *DeviceFeatures) GetDefaultDpi() *PointFloat {
	ret, err := v.getDefaultDpi(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *DeviceFeatures) getDefaultDpi(ctx context.Context) (*PointFloat, error) {
	var zero *PointFloat
	p, err := mod.getField(ctx, "DeviceFeatures_default_dpi", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newPointFloat(p)
	return ret, nil
}

type RenderFeatures struct {
	ptr uint64
}

func NewRenderFeatures(ctx context.Context) (*RenderFeatures, error) {
	o, err := mod.newObject(ctx, "RenderFeatures")
	if err != nil {
		return nil, err
	}
	return newRenderFeatures(o), nil
}

func newRenderFeatures(ptr uint64) *RenderFeatures {
	if ptr == 0 {
		return nil
	}
	return &RenderFeatures{ptr: ptr}
}

func (v *RenderFeatures) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newRenderFeaturesSlice(v []uint64) []*RenderFeatures {
	ret := make([]*RenderFeatures, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newRenderFeatures(vv))
	}
	return ret
}
func (v *RenderFeatures) SetFlags(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "RenderFeatures_flags", v.getPtr(), arg)
}

func (v *RenderFeatures) GetFlags() int64 {
	ret, err := v.getFlags(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *RenderFeatures) getFlags(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "RenderFeatures_flags", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *RenderFeatures) SetDefaultPad(_arg float64) error {
	ctx := context.Background()
	arg, err := mod.toDoubleWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "RenderFeatures_default_pad", v.getPtr(), arg)
}

func (v *RenderFeatures) GetDefaultPad() float64 {
	ret, err := v.getDefaultPad(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *RenderFeatures) getDefaultPad(ctx context.Context) (float64, error) {
	var zero float64
	p, err := mod.getField(ctx, "RenderFeatures_default_pad", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toFloat64(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *RenderFeatures) SetKnownColors(_arg []string) error {
	ctx := context.Background()
	arg, err := mod.toStringArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "RenderFeatures_known_colors", v.getPtr(), arg)
}

func (v *RenderFeatures) GetKnownColors() []string {
	ret, err := v.getKnownColors(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *RenderFeatures) getKnownColors(ctx context.Context) ([]string, error) {
	var zero []string
	p, err := mod.getField(ctx, "RenderFeatures_known_colors", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toStringSlice(ctx, slice)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *RenderFeatures) SetSizeKnownColors(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "RenderFeatures_size_known_colors", v.getPtr(), arg)
}

func (v *RenderFeatures) GetSizeKnownColors() int64 {
	ret, err := v.getSizeKnownColors(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *RenderFeatures) getSizeKnownColors(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "RenderFeatures_size_known_colors", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *RenderFeatures) SetColorType(_arg ColorType) error {
	ctx := context.Background()
	arg, err := mod.toIntWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "RenderFeatures_color_type", v.getPtr(), arg)
}

func (v *RenderFeatures) GetColorType() ColorType {
	ret, err := v.getColorType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *RenderFeatures) getColorType(ctx context.Context) (ColorType, error) {
	var zero ColorType
	p, err := mod.getField(ctx, "RenderFeatures_color_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := ColorType(p)
	return ret, nil
}

type Features struct {
	ptr uint64
}

func NewFeatures(ctx context.Context) (*Features, error) {
	o, err := mod.newObject(ctx, "Features")
	if err != nil {
		return nil, err
	}
	return newFeatures(o), nil
}

func newFeatures(ptr uint64) *Features {
	if ptr == 0 {
		return nil
	}
	return &Features{ptr: ptr}
}

func (v *Features) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newFeaturesSlice(v []uint64) []*Features {
	ret := make([]*Features, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newFeatures(vv))
	}
	return ret
}

type PluginInstalled struct {
	ptr uint64
}

func NewPluginInstalled(ctx context.Context) (*PluginInstalled, error) {
	o, err := mod.newObject(ctx, "PluginInstalled")
	if err != nil {
		return nil, err
	}
	return newPluginInstalled(o), nil
}

func newPluginInstalled(ptr uint64) *PluginInstalled {
	if ptr == 0 {
		return nil
	}
	return &PluginInstalled{ptr: ptr}
}

func (v *PluginInstalled) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newPluginInstalledSlice(v []uint64) []*PluginInstalled {
	ret := make([]*PluginInstalled, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newPluginInstalled(vv))
	}
	return ret
}
func (v *PluginInstalled) SetId(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginInstalled_id", v.getPtr(), arg)
}

func (v *PluginInstalled) GetId() int64 {
	ret, err := v.getId(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginInstalled) getId(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "PluginInstalled_id", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *PluginInstalled) SetType(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginInstalled_type", v.getPtr(), arg)
}

func (v *PluginInstalled) GetType() string {
	ret, err := v.getType(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginInstalled) getType(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PluginInstalled_type", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PluginInstalled) SetQuality(_arg int64) error {
	ctx := context.Background()
	arg, err := mod.toInt64WasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginInstalled_quality", v.getPtr(), arg)
}

func (v *PluginInstalled) GetQuality() int64 {
	ret, err := v.getQuality(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginInstalled) getQuality(ctx context.Context) (int64, error) {
	var zero int64
	p, err := mod.getField(ctx, "PluginInstalled_quality", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt64(p)
	return ret, nil
}

func (v *PluginInstalled) SetEngine(_arg any) error {
	ctx := context.Background()
	arg, err := mod.toAnyWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginInstalled_engine", v.getPtr(), arg)
}

func (v *PluginInstalled) GetEngine() any {
	ret, err := v.getEngine(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginInstalled) getEngine(ctx context.Context) (any, error) {
	var zero any
	p, err := mod.getField(ctx, "PluginInstalled_engine", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

func (v *PluginInstalled) SetFeatures(_arg any) error {
	ctx := context.Background()
	arg, err := mod.toAnyWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginInstalled_features", v.getPtr(), arg)
}

func (v *PluginInstalled) GetFeatures() any {
	ret, err := v.getFeatures(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginInstalled) getFeatures(ctx context.Context) (any, error) {
	var zero any
	p, err := mod.getField(ctx, "PluginInstalled_features", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

type PluginAPI struct {
	ptr uint64
}

func NewPluginAPI(ctx context.Context) (*PluginAPI, error) {
	o, err := mod.newObject(ctx, "PluginAPI")
	if err != nil {
		return nil, err
	}
	return newPluginAPI(o), nil
}

func newPluginAPI(ptr uint64) *PluginAPI {
	if ptr == 0 {
		return nil
	}
	return &PluginAPI{ptr: ptr}
}

func (v *PluginAPI) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newPluginAPISlice(v []uint64) []*PluginAPI {
	ret := make([]*PluginAPI, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newPluginAPI(vv))
	}
	return ret
}
func (v *PluginAPI) SetApi(_arg API) error {
	ctx := context.Background()
	arg, err := mod.toIntWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginAPI_api", v.getPtr(), arg)
}

func (v *PluginAPI) GetApi() API {
	ret, err := v.getApi(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginAPI) getApi(ctx context.Context) (API, error) {
	var zero API
	p, err := mod.getField(ctx, "PluginAPI_api", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := API(p)
	return ret, nil
}

func (v *PluginAPI) SetTypes(_arg []*PluginInstalled) error {
	ctx := context.Background()
	arg, err := mod.toObjectArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginAPI_types", v.getPtr(), arg)
}

func (v *PluginAPI) GetTypes() []*PluginInstalled {
	ret, err := v.getTypes(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginAPI) getTypes(ctx context.Context) ([]*PluginInstalled, error) {
	var zero []*PluginInstalled
	p, err := mod.getField(ctx, "PluginAPI_types", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := newPluginInstalledSlice(slice)
	return ret, nil
}

type PluginLibrary struct {
	ptr uint64
}

func NewPluginLibrary(ctx context.Context) (*PluginLibrary, error) {
	o, err := mod.newObject(ctx, "PluginLibrary")
	if err != nil {
		return nil, err
	}
	return newPluginLibrary(o), nil
}

func newPluginLibrary(ptr uint64) *PluginLibrary {
	if ptr == 0 {
		return nil
	}
	return &PluginLibrary{ptr: ptr}
}

func (v *PluginLibrary) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func newPluginLibrarySlice(v []uint64) []*PluginLibrary {
	ret := make([]*PluginLibrary, 0, len(v))
	for _, vv := range v {
		ret = append(ret, newPluginLibrary(vv))
	}
	return ret
}
func (v *PluginLibrary) SetPackageName(_arg string) error {
	ctx := context.Background()
	arg, err := mod.toStringWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginLibrary_package_name", v.getPtr(), arg)
}

func (v *PluginLibrary) GetPackageName() string {
	ret, err := v.getPackageName(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginLibrary) getPackageName(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.getField(ctx, "PluginLibrary_package_name", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *PluginLibrary) SetApis(_arg []*PluginAPI) error {
	ctx := context.Background()
	arg, err := mod.toObjectArrayWasmValue(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "PluginLibrary_apis", v.getPtr(), arg)
}

func (v *PluginLibrary) GetApis() []*PluginAPI {
	ret, err := v.getApis(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *PluginLibrary) getApis(ctx context.Context) ([]*PluginAPI, error) {
	var zero []*PluginAPI
	p, err := mod.getField(ctx, "PluginLibrary_apis", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret := newPluginAPISlice(slice)
	return ret, nil
}

type ObjectTag int

var (
	GRAPH    ObjectTag = 0
	NODE     ObjectTag = 1
	OUT_EDGE ObjectTag = 2
	IN_EDGE  ObjectTag = 3
	EDGE     ObjectTag = 4
)

func (v ObjectTag) String() string {
	switch v {
	case GRAPH:
		return "GRAPH"
	case NODE:
		return "NODE"
	case OUT_EDGE:
		return "OUT_EDGE"
	case IN_EDGE:
		return "IN_EDGE"
	case EDGE:
		return "EDGE"
	}
	return ""
}

type ErrorLevel int

var (
	WARN ErrorLevel = 0
	ERR  ErrorLevel = 1
	MAX  ErrorLevel = 2
	PREV ErrorLevel = 3
)

func (v ErrorLevel) String() string {
	switch v {
	case WARN:
		return "WARN"
	case ERR:
		return "ERR"
	case MAX:
		return "MAX"
	case PREV:
		return "PREV"
	}
	return ""
}

type ImageType int

var (
	IMAGE_TYPE_NULL ImageType = 0
	IMAGE_TYPE_BMP  ImageType = 1
	IMAGE_TYPE_GIF  ImageType = 2
	IMAGE_TYPE_PNG  ImageType = 3
	IMAGE_TYPE_JPEG ImageType = 4
	IMAGE_TYPE_PDF  ImageType = 5
	IMAGE_TYPE_PS   ImageType = 6
	IMAGE_TYPE_EPS  ImageType = 7
	IMAGE_TYPE_SVG  ImageType = 8
	IMAGE_TYPE_XML  ImageType = 9
	IMAGE_TYPE_RIFF ImageType = 10
	IMAGE_TYPE_WEBP ImageType = 11
	IMAGE_TYPE_ICO  ImageType = 12
	IMAGE_TYPE_TIFF ImageType = 13
)

func (v ImageType) String() string {
	switch v {
	case IMAGE_TYPE_NULL:
		return "IMAGE_TYPE_NULL"
	case IMAGE_TYPE_BMP:
		return "IMAGE_TYPE_BMP"
	case IMAGE_TYPE_GIF:
		return "IMAGE_TYPE_GIF"
	case IMAGE_TYPE_PNG:
		return "IMAGE_TYPE_PNG"
	case IMAGE_TYPE_JPEG:
		return "IMAGE_TYPE_JPEG"
	case IMAGE_TYPE_PDF:
		return "IMAGE_TYPE_PDF"
	case IMAGE_TYPE_PS:
		return "IMAGE_TYPE_PS"
	case IMAGE_TYPE_EPS:
		return "IMAGE_TYPE_EPS"
	case IMAGE_TYPE_SVG:
		return "IMAGE_TYPE_SVG"
	case IMAGE_TYPE_XML:
		return "IMAGE_TYPE_XML"
	case IMAGE_TYPE_RIFF:
		return "IMAGE_TYPE_RIFF"
	case IMAGE_TYPE_WEBP:
		return "IMAGE_TYPE_WEBP"
	case IMAGE_TYPE_ICO:
		return "IMAGE_TYPE_ICO"
	case IMAGE_TYPE_TIFF:
		return "IMAGE_TYPE_TIFF"
	}
	return ""
}

type ObjectType int

var (
	ROOTGRAPH_OBJTYPE ObjectType = 0
	CLUSTER_OBJTYPE   ObjectType = 1
	NODE_OBJTYPE      ObjectType = 2
	EDGE_OBJTYPE      ObjectType = 3
)

func (v ObjectType) String() string {
	switch v {
	case ROOTGRAPH_OBJTYPE:
		return "ROOTGRAPH_OBJTYPE"
	case CLUSTER_OBJTYPE:
		return "CLUSTER_OBJTYPE"
	case NODE_OBJTYPE:
		return "NODE_OBJTYPE"
	case EDGE_OBJTYPE:
		return "EDGE_OBJTYPE"
	}
	return ""
}

type MapShapeType int

var (
	MAP_RECTANGLE MapShapeType = 0
	MAP_CIRCLE    MapShapeType = 1
	MAP_POLYGON   MapShapeType = 2
)

func (v MapShapeType) String() string {
	switch v {
	case MAP_RECTANGLE:
		return "MAP_RECTANGLE"
	case MAP_CIRCLE:
		return "MAP_CIRCLE"
	case MAP_POLYGON:
		return "MAP_POLYGON"
	}
	return ""
}

type EmitState int

var (
	EMIT_GDRAW  EmitState = 0
	EMIT_CDRAW  EmitState = 1
	EMIT_TDRAW  EmitState = 2
	EMIT_HDRAW  EmitState = 3
	EMIT_GLABEL EmitState = 4
	EMIT_CLABEL EmitState = 5
	EMIT_TLABEL EmitState = 6
	EMIT_HLABEL EmitState = 7
	EMIT_NDRAW  EmitState = 8
	EMIT_EDRAW  EmitState = 9
	EMIT_NLABEL EmitState = 10
	EMIT_ELABEL EmitState = 11
)

func (v EmitState) String() string {
	switch v {
	case EMIT_GDRAW:
		return "EMIT_GDRAW"
	case EMIT_CDRAW:
		return "EMIT_CDRAW"
	case EMIT_TDRAW:
		return "EMIT_TDRAW"
	case EMIT_HDRAW:
		return "EMIT_HDRAW"
	case EMIT_GLABEL:
		return "EMIT_GLABEL"
	case EMIT_CLABEL:
		return "EMIT_CLABEL"
	case EMIT_TLABEL:
		return "EMIT_TLABEL"
	case EMIT_HLABEL:
		return "EMIT_HLABEL"
	case EMIT_NDRAW:
		return "EMIT_NDRAW"
	case EMIT_EDRAW:
		return "EMIT_EDRAW"
	case EMIT_NLABEL:
		return "EMIT_NLABEL"
	case EMIT_ELABEL:
		return "EMIT_ELABEL"
	}
	return ""
}

type EmitType int

var (
	EMIT_SORTED        EmitType = 0
	EMIT_COLORS        EmitType = 1
	EMIT_CLUSTERS_LAST EmitType = 2
	EMIT_PREORDER      EmitType = 3
	EMIT_EDGE_SORTED   EmitType = 4
)

func (v EmitType) String() string {
	switch v {
	case EMIT_SORTED:
		return "EMIT_SORTED"
	case EMIT_COLORS:
		return "EMIT_COLORS"
	case EMIT_CLUSTERS_LAST:
		return "EMIT_CLUSTERS_LAST"
	case EMIT_PREORDER:
		return "EMIT_PREORDER"
	case EMIT_EDGE_SORTED:
		return "EMIT_EDGE_SORTED"
	}
	return ""
}

type DeviceType int

var (
	DEVICE_DOES_PAGES        DeviceType = 0
	DEVICE_DOES_LAYERS       DeviceType = 1
	DEVICE_EVENTS            DeviceType = 2
	DEVICE_DOES_TRUECOLOR    DeviceType = 3
	DEVICE_BINARY_FORMAT     DeviceType = 4
	DEVICE_COMPRESSED_FORMAT DeviceType = 5
	DEVICE_NO_WRITER         DeviceType = 6
)

func (v DeviceType) String() string {
	switch v {
	case DEVICE_DOES_PAGES:
		return "DEVICE_DOES_PAGES"
	case DEVICE_DOES_LAYERS:
		return "DEVICE_DOES_LAYERS"
	case DEVICE_EVENTS:
		return "DEVICE_EVENTS"
	case DEVICE_DOES_TRUECOLOR:
		return "DEVICE_DOES_TRUECOLOR"
	case DEVICE_BINARY_FORMAT:
		return "DEVICE_BINARY_FORMAT"
	case DEVICE_COMPRESSED_FORMAT:
		return "DEVICE_COMPRESSED_FORMAT"
	case DEVICE_NO_WRITER:
		return "DEVICE_NO_WRITER"
	}
	return ""
}

type RenderType int

var (
	RENDER_Y_GOES_DOWN        RenderType = 0
	RENDER_DOES_TRANSFORM     RenderType = 1
	RENDER_DOES_LABELS        RenderType = 2
	RENDER_DOES_MAPS          RenderType = 3
	RENDER_DOES_MAP_RECTANGLE RenderType = 4
	RENDER_DOES_MAP_CIRCLE    RenderType = 5
	RENDER_DOES_MAP_POLYGON   RenderType = 6
	RENDER_DOES_MAP_ELLIPSE   RenderType = 7
	RENDER_DOES_MAP_BSPLINE   RenderType = 8
	RENDER_DOES_TOOLTIPS      RenderType = 9
	RENDER_DOES_TARGETS       RenderType = 10
	RENDER_DOES_Z             RenderType = 11
	RENDER_NO_WHITE_BG        RenderType = 12
)

func (v RenderType) String() string {
	switch v {
	case RENDER_Y_GOES_DOWN:
		return "RENDER_Y_GOES_DOWN"
	case RENDER_DOES_TRANSFORM:
		return "RENDER_DOES_TRANSFORM"
	case RENDER_DOES_LABELS:
		return "RENDER_DOES_LABELS"
	case RENDER_DOES_MAPS:
		return "RENDER_DOES_MAPS"
	case RENDER_DOES_MAP_RECTANGLE:
		return "RENDER_DOES_MAP_RECTANGLE"
	case RENDER_DOES_MAP_CIRCLE:
		return "RENDER_DOES_MAP_CIRCLE"
	case RENDER_DOES_MAP_POLYGON:
		return "RENDER_DOES_MAP_POLYGON"
	case RENDER_DOES_MAP_ELLIPSE:
		return "RENDER_DOES_MAP_ELLIPSE"
	case RENDER_DOES_MAP_BSPLINE:
		return "RENDER_DOES_MAP_BSPLINE"
	case RENDER_DOES_TOOLTIPS:
		return "RENDER_DOES_TOOLTIPS"
	case RENDER_DOES_TARGETS:
		return "RENDER_DOES_TARGETS"
	case RENDER_DOES_Z:
		return "RENDER_DOES_Z"
	case RENDER_NO_WHITE_BG:
		return "RENDER_NO_WHITE_BG"
	}
	return ""
}

type RequiredType int

var (
	LAYOUT_NOT_REQUIRED RequiredType = 0
	OUTPUT_NOT_REQUIRED RequiredType = 1
)

func (v RequiredType) String() string {
	switch v {
	case LAYOUT_NOT_REQUIRED:
		return "LAYOUT_NOT_REQUIRED"
	case OUTPUT_NOT_REQUIRED:
		return "OUTPUT_NOT_REQUIRED"
	}
	return ""
}

type PenType int

var (
	PEN_NONE   PenType = 0
	PEN_DASHED PenType = 1
	PEN_DOTTED PenType = 2
	PEN_SOLID  PenType = 3
)

func (v PenType) String() string {
	switch v {
	case PEN_NONE:
		return "PEN_NONE"
	case PEN_DASHED:
		return "PEN_DASHED"
	case PEN_DOTTED:
		return "PEN_DOTTED"
	case PEN_SOLID:
		return "PEN_SOLID"
	}
	return ""
}

type FillType int

var (
	FILL_NONE   FillType = 0
	FILL_SOLID  FillType = 1
	FILL_LINEAR FillType = 2
	FILL_RADIAL FillType = 3
)

func (v FillType) String() string {
	switch v {
	case FILL_NONE:
		return "FILL_NONE"
	case FILL_SOLID:
		return "FILL_SOLID"
	case FILL_LINEAR:
		return "FILL_LINEAR"
	case FILL_RADIAL:
		return "FILL_RADIAL"
	}
	return ""
}

type FontType int

var (
	FONT_REGULAR FontType = 0
	FONT_BOLD    FontType = 1
	FONT_ITALIC  FontType = 2
)

func (v FontType) String() string {
	switch v {
	case FONT_REGULAR:
		return "FONT_REGULAR"
	case FONT_BOLD:
		return "FONT_BOLD"
	case FONT_ITALIC:
		return "FONT_ITALIC"
	}
	return ""
}

type LabelType int

var (
	LABEL_PLAIN LabelType = 0
	LABEL_HTML  LabelType = 1
)

func (v LabelType) String() string {
	switch v {
	case LABEL_PLAIN:
		return "LABEL_PLAIN"
	case LABEL_HTML:
		return "LABEL_HTML"
	}
	return ""
}

type ColorType int

var (
	HSVA_DOUBLE  ColorType = 0
	RGBA_BYTE    ColorType = 1
	RGBA_WORD    ColorType = 2
	RGBA_DOUBLE  ColorType = 3
	COLOR_STRING ColorType = 4
	COLOR_INDEX  ColorType = 5
)

func (v ColorType) String() string {
	switch v {
	case HSVA_DOUBLE:
		return "HSVA_DOUBLE"
	case RGBA_BYTE:
		return "RGBA_BYTE"
	case RGBA_WORD:
		return "RGBA_WORD"
	case RGBA_DOUBLE:
		return "RGBA_DOUBLE"
	case COLOR_STRING:
		return "COLOR_STRING"
	case COLOR_INDEX:
		return "COLOR_INDEX"
	}
	return ""
}

type API int

var (
	API_RENDER     API = 0
	API_LAYOUT     API = 1
	API_TEXTLAYOUT API = 2
	API_DEVICE     API = 3
	API_LOADIMAGE  API = 4
)

func (v API) String() string {
	switch v {
	case API_RENDER:
		return "API_RENDER"
	case API_LAYOUT:
		return "API_LAYOUT"
	case API_TEXTLAYOUT:
		return "API_TEXTLAYOUT"
	case API_DEVICE:
		return "API_DEVICE"
	case API_LOADIMAGE:
		return "API_LOADIMAGE"
	}
	return ""
}

func (v *Graph) Close(ctx context.Context) (int, error) {
	var zero int
	p, err := mod.callWithRet(ctx, "Graph_close", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) IsSimple(ctx context.Context) (int, error) {
	var zero int
	p, err := mod.callWithRet(ctx, "Graph_isSimple", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) Node(ctx context.Context, _arg0 string, _arg1 int) (*Node, error) {
	var zero *Node
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_node", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newNode(p)
	return ret, nil
}

func (v *Graph) IdNode(ctx context.Context, _arg0 uint64, _arg1 int) (*Node, error) {
	var zero *Node
	arg0, err := mod.toUint64WasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_idNode", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newNode(p)
	return ret, nil
}

func (v *Graph) SubNode(ctx context.Context, _arg0 *Node, _arg1 int) (*Node, error) {
	var zero *Node
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_subNode", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newNode(p)
	return ret, nil
}

func (v *Graph) FirstNode(ctx context.Context) (*Node, error) {
	var zero *Node
	p, err := mod.callWithRet(ctx, "Graph_firstNode", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newNode(p)
	return ret, nil
}

func (v *Graph) NextNode(ctx context.Context, _arg0 *Node) (*Node, error) {
	var zero *Node
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_nextNode", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := newNode(p)
	return ret, nil
}

func (v *Graph) LastNode(ctx context.Context) (*Node, error) {
	var zero *Node
	p, err := mod.callWithRet(ctx, "Graph_lastNode", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newNode(p)
	return ret, nil
}

func (v *Graph) PrevNode(ctx context.Context, _arg0 *Node) (*Node, error) {
	var zero *Node
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_prevNode", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := newNode(p)
	return ret, nil
}

func (v *Graph) SubRep(ctx context.Context, _arg0 *Node) (*SubNode, error) {
	var zero *SubNode
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_subRep", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := newSubNode(p)
	return ret, nil
}

func (v *Node) Before(ctx context.Context, _arg0 *Node) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Node_before", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) Edge(ctx context.Context, _arg0 *Node, _arg1 *Node, _arg2 string, _arg3 int) (*Edge, error) {
	var zero *Edge
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toObjectWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toStringWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	arg3, err := mod.toIntWasmValue(ctx, _arg3)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_edge", v.getPtr(), arg0, arg1, arg2, arg3)
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

func (v *Graph) IdEdge(ctx context.Context, _arg0 *Node, _arg1 *Node, _arg2 uint64, _arg3 int) (*Edge, error) {
	var zero *Edge
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toObjectWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toUint64WasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	arg3, err := mod.toIntWasmValue(ctx, _arg3)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_idEdge", v.getPtr(), arg0, arg1, arg2, arg3)
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

func (v *Graph) SubEdge(ctx context.Context, _arg0 *Edge, _arg1 int) (*Edge, error) {
	var zero *Edge
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_subEdge", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

func (v *Graph) FirstIn(ctx context.Context, _arg0 *Node) (*Edge, error) {
	var zero *Edge
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_firstIn", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

func (v *Graph) NextIn(ctx context.Context, _arg0 *Edge) (*Edge, error) {
	var zero *Edge
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_nextIn", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

func (v *Graph) FirstOut(ctx context.Context, _arg0 *Node) (*Edge, error) {
	var zero *Edge
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_firstOut", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

func (v *Graph) NextOut(ctx context.Context, _arg0 *Edge) (*Edge, error) {
	var zero *Edge
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_nextOut", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

func (v *Graph) FirstEdge(ctx context.Context, _arg0 *Node) (*Edge, error) {
	var zero *Edge
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_firstEdge", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

func (v *Graph) NextEdge(ctx context.Context, _arg0 *Edge, _arg1 *Node) (*Edge, error) {
	var zero *Edge
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toObjectWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_nextEdge", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newEdge(p)
	return ret, nil
}

func (v *Graph) Contains(ctx context.Context, _arg0 any) (int, error) {
	var zero int
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_contains", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Node) ReLabel(ctx context.Context, _arg0 string) (int, error) {
	var zero int
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Node_reLabel", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) Delete(ctx context.Context, _arg0 any) (int, error) {
	var zero int
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_delete", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) DeleteSubGraph(ctx context.Context, _arg0 *Graph) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_deleteSubGraph", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) DeleteNode(ctx context.Context, _arg0 *Node) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_deleteNode", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) DeleteEdge(ctx context.Context, _arg0 *Edge) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_deleteEdge", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) Strdup(ctx context.Context, _arg0 string) (string, error) {
	var zero string
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_strdup", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Graph) StrdupHTML(ctx context.Context, _arg0 string) (string, error) {
	var zero string
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_strdupHTML", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Graph) StrBind(ctx context.Context, _arg0 string) (string, error) {
	var zero string
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_strBind", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Graph) StrFree(ctx context.Context, _arg0 string) (int, error) {
	var zero int
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_strFree", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) Attr(ctx context.Context, _arg0 int, _arg1 string, _arg2 string) (*Sym, error) {
	var zero *Sym
	arg0, err := mod.toIntWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toStringWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_attr", v.getPtr(), arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := newSym(p)
	return ret, nil
}

func (v *Graph) NextAttr(ctx context.Context, _arg0 int, _arg1 *Sym) (*Sym, error) {
	var zero *Sym
	arg0, err := mod.toIntWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toObjectWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_nextAttr", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newSym(p)
	return ret, nil
}

func (v *Graph) Init(ctx context.Context, _arg0 int, _arg1 string, _arg2 int, _arg3 int) error {
	arg0, err := mod.toIntWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return err
	}
	arg2, err := mod.toIntWasmValue(ctx, _arg2)
	if err != nil {
		return err
	}
	arg3, err := mod.toIntWasmValue(ctx, _arg3)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "Graph_init", v.getPtr(), arg0, arg1, arg2, arg3); err != nil {
		return err
	}
	return nil
}

func (v *Graph) Clean(ctx context.Context, _arg0 int, _arg1 string) error {
	arg0, err := mod.toIntWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "Graph_clean", v.getPtr(), arg0, arg1); err != nil {
		return err
	}
	return nil
}

func (v *Graph) SubGraph(ctx context.Context, _arg0 string, _arg1 int) (*Graph, error) {
	var zero *Graph
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_subGraph", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *Graph) IdSubGraph(ctx context.Context, _arg0 uint64, _arg1 int) (*Graph, error) {
	var zero *Graph
	arg0, err := mod.toUint64WasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_idSubGraph", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *Graph) FirstSubGraph(ctx context.Context) (*Graph, error) {
	var zero *Graph
	p, err := mod.callWithRet(ctx, "Graph_firstSubGraph", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *Graph) NextSubGraph(ctx context.Context) (*Graph, error) {
	var zero *Graph
	p, err := mod.callWithRet(ctx, "Graph_nextSubGraph", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *Graph) Parent(ctx context.Context) (*Graph, error) {
	var zero *Graph
	p, err := mod.callWithRet(ctx, "Graph_parent", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *Graph) NodeNum(ctx context.Context) (int, error) {
	var zero int
	p, err := mod.callWithRet(ctx, "Graph_nodeNum", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) EdgeNum(ctx context.Context) (int, error) {
	var zero int
	p, err := mod.callWithRet(ctx, "Graph_edgeNum", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) SubGraphNum(ctx context.Context) (int, error) {
	var zero int
	p, err := mod.callWithRet(ctx, "Graph_subGraphNum", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) Degree(ctx context.Context, _arg0 *Node, _arg1 int, _arg2 int) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toIntWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_degree", v.getPtr(), arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) CountUniqueEdges(ctx context.Context, _arg0 *Node, _arg1 int, _arg2 int) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toIntWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_countUniqueEdges", v.getPtr(), arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) Alloc(ctx context.Context, _arg0 uint64) (any, error) {
	var zero any
	arg0, err := mod.toUint64WasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_alloc", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

func (v *Graph) Realloc(ctx context.Context, _arg0 any, _arg1 uint64, _arg2 uint64) (any, error) {
	var zero any
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toUint64WasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toUint64WasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Graph_realloc", v.getPtr(), arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

func (v *Graph) Free(ctx context.Context, _arg0 any) error {
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "Graph_free", v.getPtr(), arg0); err != nil {
		return err
	}
	return nil
}

func (v *Dict) Close(ctx context.Context) (int, error) {
	var zero int
	p, err := mod.callWithRet(ctx, "Dict_close", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Dict) View(ctx context.Context, _arg0 *Dict) (*Dict, error) {
	var zero *Dict
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Dict_view", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := newDict(p)
	return ret, nil
}

func (v *Dict) Disc(ctx context.Context, _arg0 *DictDisc) (*DictDisc, error) {
	var zero *DictDisc
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Dict_disc", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := newDictDisc(p)
	return ret, nil
}

func (v *Dict) Method(ctx context.Context, _arg0 *DictMethod) (*DictMethod, error) {
	var zero *DictMethod
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Dict_method", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := newDictMethod(p)
	return ret, nil
}

func (v *Dict) Flatten(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.callWithRet(ctx, "Dict_flatten", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *Dict) Extract(ctx context.Context) (*DictLink, error) {
	var zero *DictLink
	p, err := mod.callWithRet(ctx, "Dict_extract", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newDictLink(p)
	return ret, nil
}

func (v *Dict) Restore(ctx context.Context, _arg0 *DictLink) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Dict_restore", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Dict) Walk(ctx context.Context, _arg0 *CallbackFunc[func(context.Context, any, any) (int, error)], _arg1 any) (int, error) {
	var zero int
	if mod.lookupFuncMap.DictWalk == nil {
		return zero, fmt.Errorf("cannot find lookup function. you must call Register_DictWalk before")
	}
	mod.callbackFuncMap.DictWalk[_arg0.funcID] = _arg0.cb
	arg0, err := mod.toFuncWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toAnyWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Dict_walk", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Dict) Renew(ctx context.Context, _arg0 any) (any, error) {
	var zero any
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Dict_renew", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

func (v *Dict) Size(ctx context.Context) (int, error) {
	var zero int
	p, err := mod.callWithRet(ctx, "Dict_size", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Dict) Stat(ctx context.Context, _arg0 *DictStat, _arg1 int) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Dict_stat", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Context) Info(ctx context.Context) ([]string, error) {
	var zero []string
	p, err := mod.callWithRet(ctx, "Context_info", v.getPtr())
	if err != nil {
		return zero, err
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toStringSlice(ctx, slice)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Context) Version(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.callWithRet(ctx, "Context_version", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Context) BuildDate(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.callWithRet(ctx, "Context_buildDate", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Context) ParseArgs(ctx context.Context, _arg0 int, _arg1 []string) (int, error) {
	var zero int
	arg0, err := mod.toIntWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringArrayWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Context_parseArgs", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Context) NextInputGraph(ctx context.Context) (*Graph, error) {
	var zero *Graph
	p, err := mod.callWithRet(ctx, "Context_nextInputGraph", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *Context) PluginsGraph(ctx context.Context) (*Graph, error) {
	var zero *Graph
	p, err := mod.callWithRet(ctx, "Context_pluginsGraph", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func (v *Context) Layout(ctx context.Context, _arg0 *Graph, _arg1 string) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Context_layout", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Context) LayoutJobs(ctx context.Context, _arg0 *Graph) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Context_layoutJobs", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Graph) AttachAttrs(ctx context.Context) error {
	if err := mod.call(ctx, "Graph_attachAttrs", v.getPtr()); err != nil {
		return err
	}
	return nil
}

func (v *Context) Render(ctx context.Context, _arg0 *Graph, _arg1 string, _arg2 *File) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toObjectWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Context_render", v.getPtr(), arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Context) RenderFilename(ctx context.Context, _arg0 *Graph, _arg1 string, _arg2 string) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toStringWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Context_renderFilename", v.getPtr(), arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Context) RenderContext(ctx context.Context, _arg0 *Graph, _arg1 string, _arg2 any) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toAnyWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Context_renderContext", v.getPtr(), arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Context) RenderData(ctx context.Context, _arg0 *Graph, _arg1 string, _arg2 *string, _arg3 *uint) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toPtrWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	arg3, err := mod.toPtrWasmValue(ctx, _arg3)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Context_renderData", v.getPtr(), arg0, arg1, arg2, arg3)
	if err != nil {
		return zero, err
	}
	{
		p, err := mod.readU32(arg2)
		if err != nil {
			return zero, err
		}
		value, err := mod.toString(ctx, p)
		if err != nil {
			return zero, err
		}
		*_arg2 = value
	}
	{
		p, err := mod.readU32(arg3)
		if err != nil {
			return zero, err
		}
		value := mod.toUint(p)
		*_arg3 = value
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Context) RenderJobs(ctx context.Context, _arg0 *Graph) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Context_renderJobs", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Context) Finalize(ctx context.Context) error {
	if err := mod.call(ctx, "Context_finalize", v.getPtr()); err != nil {
		return err
	}
	return nil
}

func (v *Context) FreeContext(ctx context.Context) (int, error) {
	var zero int
	p, err := mod.callWithRet(ctx, "Context_freeContext", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Context) FreeLayout(ctx context.Context, _arg0 *Graph) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Context_freeLayout", v.getPtr(), arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Context) PluginList(ctx context.Context, _arg0 string, _arg1 *int) ([]string, error) {
	var zero []string
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toPtrWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "Context_pluginList", v.getPtr(), arg0, arg1)
	if err != nil {
		return zero, err
	}
	{
		p, err := mod.readU32(arg1)
		if err != nil {
			return zero, err
		}
		value := mod.toInt(p)
		*_arg1 = value
	}
	slice, err := mod.toSlice(ctx, p)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toStringSlice(ctx, slice)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func (v *Context) AddLibrary(ctx context.Context, _arg0 *PluginLibrary) error {
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "Context_addLibrary", v.getPtr(), arg0); err != nil {
		return err
	}
	return nil
}

func (v *Graph) ToolTred(ctx context.Context) (int, error) {
	var zero int
	p, err := mod.callWithRet(ctx, "Graph_toolTred", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func (v *Context) Clone(ctx context.Context) (*Context, error) {
	var zero *Context
	p, err := mod.callWithRet(ctx, "Context_clone", v.getPtr())
	if err != nil {
		return zero, err
	}
	ret := newContext(p)
	return ret, nil
}

func (v *Context) FreeClonedContext(ctx context.Context) error {
	if err := mod.call(ctx, "Context_freeClonedContext", v.getPtr()); err != nil {
		return err
	}
	return nil
}

func PushDisc(ctx context.Context, _arg0 *Graph, _arg1 *ClientEventCallback, _arg2 any) error {
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	arg1, err := mod.toObjectWasmValue(ctx, _arg1)
	if err != nil {
		return err
	}
	arg2, err := mod.toAnyWasmValue(ctx, _arg2)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "pushDisc", arg0, arg1, arg2); err != nil {
		return err
	}
	return nil
}

func PopDisc(ctx context.Context, _arg0 *Graph, _arg1 *ClientEventCallback) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toObjectWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "popDisc", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func Open(ctx context.Context, _arg0 string, _arg1 *GraphDescriptor, _arg2 *ClientDiscipline) (*Graph, error) {
	var zero *Graph
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toObjectWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toObjectWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "open", arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func Read(ctx context.Context, _arg0 string, _arg1 *ClientDiscipline) (*Graph, error) {
	var zero *Graph
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toObjectWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "read", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func MemRead(ctx context.Context, _arg0 string) (*Graph, error) {
	var zero *Graph
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "memRead", arg0)
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func Readline(ctx context.Context, _arg0 int) error {
	arg0, err := mod.toIntWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "readline", arg0); err != nil {
		return err
	}
	return nil
}

func SetFile(ctx context.Context, _arg0 string) error {
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "setFile", arg0); err != nil {
		return err
	}
	return nil
}

func Concat(ctx context.Context, _arg0 *Graph, _arg1 any, _arg2 *ClientDiscipline) (*Graph, error) {
	var zero *Graph
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toAnyWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toObjectWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "concat", arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func Write(ctx context.Context, _arg0 *Graph, _arg1 any) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toAnyWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "write", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func IsDirected(ctx context.Context, _arg0 *Graph) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "isDirected", arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func IsUndirected(ctx context.Context, _arg0 *Graph) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "isUndirected", arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func IsStrict(ctx context.Context, _arg0 *Graph) (int, error) {
	var zero int
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "isStrict", arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func GraphOf(ctx context.Context, _arg0 any) (*Graph, error) {
	var zero *Graph
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "graphOf", arg0)
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func GraphRoot(ctx context.Context, _arg0 any) (*Graph, error) {
	var zero *Graph
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "graphRoot", arg0)
	if err != nil {
		return zero, err
	}
	ret := newGraph(p)
	return ret, nil
}

func GraphNameOf(ctx context.Context, _arg0 any) (string, error) {
	var zero string
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "graphNameOf", arg0)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func ObjectKind(ctx context.Context, _arg0 any) (int, error) {
	var zero int
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "objectKind", arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func HtmlStr(ctx context.Context, _arg0 string) (bool, error) {
	var zero bool
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "htmlStr", arg0)
	if err != nil {
		return zero, err
	}
	ret := mod.toBool(p)
	return ret, nil
}

func Canon(ctx context.Context, _arg0 string, _arg1 int) (string, error) {
	var zero string
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "canon", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func StrCanon(ctx context.Context, _arg0 string, _arg1 string) (string, error) {
	var zero string
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "strCanon", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func CanonStr(ctx context.Context, _arg0 string) (string, error) {
	var zero string
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "canonStr", arg0)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func AttrSym(ctx context.Context, _arg0 *Object, _arg1 string) (*Sym, error) {
	var zero *Sym
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "attrSym", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newSym(p)
	return ret, nil
}

func CopyAttr(ctx context.Context, _arg0 any, _arg1 any) (int, error) {
	var zero int
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toAnyWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "copyAttr", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func BindRecord(ctx context.Context, _arg0 any, _arg1 string, _arg2 uint, _arg3 int) (any, error) {
	var zero any
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toUintWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	arg3, err := mod.toIntWasmValue(ctx, _arg3)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "bindRecord", arg0, arg1, arg2, arg3)
	if err != nil {
		return zero, err
	}
	ret := mod.toAny(p)
	return ret, nil
}

func GetRecord(ctx context.Context, _arg0 any, _arg1 string, _arg2 int) (*Record, error) {
	var zero *Record
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toIntWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "getRecord", arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := newRecord(p)
	return ret, nil
}

func DeleteRecord(ctx context.Context, _arg0 any, _arg1 string) (int, error) {
	var zero int
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "deleteRecord", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func GetStr(ctx context.Context, _arg0 any, _arg1 string) (string, error) {
	var zero string
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "getStr", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func GetSymName(ctx context.Context, _arg0 any, _arg1 *Sym) (string, error) {
	var zero string
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toObjectWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "getSymName", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func SetStr(ctx context.Context, _arg0 any, _arg1 string, _arg2 string) (int, error) {
	var zero int
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toStringWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "setStr", arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func SetSymName(ctx context.Context, _arg0 any, _arg1 *Sym, _arg2 string) (int, error) {
	var zero int
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toObjectWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toStringWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "setSymName", arg0, arg1, arg2)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func SafeSetStr(ctx context.Context, _arg0 any, _arg1 string, _arg2 string, _arg3 string) (int, error) {
	var zero int
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	arg2, err := mod.toStringWasmValue(ctx, _arg2)
	if err != nil {
		return zero, err
	}
	arg3, err := mod.toStringWasmValue(ctx, _arg3)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "safeSetStr", arg0, arg1, arg2, arg3)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func SetError(ctx context.Context, _arg0 ErrorLevel) (ErrorLevel, error) {
	var zero ErrorLevel
	arg0, err := mod.toIntWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "setError", arg0)
	if err != nil {
		return zero, err
	}
	ret := ErrorLevel(p)
	return ret, nil
}

func LastError(ctx context.Context) (string, error) {
	var zero string
	p, err := mod.callWithRet(ctx, "lastError")
	if err != nil {
		return zero, err
	}
	ret, err := mod.toString(ctx, p)
	if err != nil {
		return zero, err
	}
	return ret, nil
}

func Error(ctx context.Context, _arg0 ErrorLevel, _arg1 string) (int, error) {
	var zero int
	arg0, err := mod.toIntWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toStringWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "error", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func Errorf(ctx context.Context, _arg0 string) error {
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "errorf", arg0); err != nil {
		return err
	}
	return nil
}

func Warningf(ctx context.Context, _arg0 string) error {
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "warningf", arg0); err != nil {
		return err
	}
	return nil
}

func ErrorNum(ctx context.Context) (int, error) {
	var zero int
	p, err := mod.callWithRet(ctx, "errorNum")
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func ResetErrors(ctx context.Context) (int, error) {
	var zero int
	p, err := mod.callWithRet(ctx, "resetErrors")
	if err != nil {
		return zero, err
	}
	ret := mod.toInt(p)
	return ret, nil
}

func SetErrorf(ctx context.Context, _arg0 *CallbackFunc[func(context.Context, string) (int, error)]) error {
	if mod.lookupFuncMap.UserRef == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_UserRef before")
	}
	mod.callbackFuncMap.UserRef[_arg0.funcID] = _arg0.cb
	arg0, err := mod.toFuncWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "setErrorf", arg0); err != nil {
		return err
	}
	return nil
}

func NewDictWithDisc(ctx context.Context, _arg0 *DictDisc, _arg1 *DictMethod) (*Dict, error) {
	var zero *Dict
	arg0, err := mod.toObjectWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toObjectWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "newDictWithDisc", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newDict(p)
	return ret, nil
}

func StrHash(ctx context.Context, _arg0 any, _arg1 int) (uint, error) {
	var zero uint
	arg0, err := mod.toAnyWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "strHash", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := mod.toUint(p)
	return ret, nil
}

func Toggle(ctx context.Context, _arg0 int) error {
	arg0, err := mod.toIntWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "toggle", arg0); err != nil {
		return err
	}
	return nil
}

func NewContextWithSymList(ctx context.Context, _arg0 []*SymList, _arg1 int) (*Context, error) {
	var zero *Context
	arg0, err := mod.toObjectArrayWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "newContextWithSymList", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newContext(p)
	return ret, nil
}

func GetContext(ctx context.Context) (*Context, error) {
	var zero *Context
	p, err := mod.callWithRet(ctx, "getContext")
	if err != nil {
		return zero, err
	}
	ret := newContext(p)
	return ret, nil
}

func GetContextWithPlugins(ctx context.Context, _arg0 []*SymList, _arg1 int) (*Context, error) {
	var zero *Context
	arg0, err := mod.toObjectArrayWasmValue(ctx, _arg0)
	if err != nil {
		return zero, err
	}
	arg1, err := mod.toIntWasmValue(ctx, _arg1)
	if err != nil {
		return zero, err
	}
	p, err := mod.callWithRet(ctx, "getContextWithPlugins", arg0, arg1)
	if err != nil {
		return zero, err
	}
	ret := newContext(p)
	return ret, nil
}

func FreeRenderData(ctx context.Context, _arg0 string) error {
	arg0, err := mod.toStringWasmValue(ctx, _arg0)
	if err != nil {
		return err
	}
	if err := mod.call(ctx, "freeRenderData", arg0); err != nil {
		return err
	}
	return nil
}
