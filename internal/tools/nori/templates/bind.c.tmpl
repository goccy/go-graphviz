// Code generated by protoc-gen-nori. DO NOT EDIT!

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

// this is imported by host function in Go.
void *wasm_bridge_get_go_funcptr(void *funcbaseptr);

{{ range .Headers }}
#include "{{ . }}"
{{- end }}

typedef struct { char *p; int n; } GoString;
typedef struct { int len; void *data; } GoSlice;
typedef struct { void *t; void *v; } GoInterface;

static GoString *newStringWithLength(char *src, int length) {
  GoString *ret = (GoString *)malloc(sizeof(GoString));
  ret->p = src;
  ret->n = length;
  return ret;
}

static GoString *newString(char *src) {
  return newStringWithLength(src, strlen(src));
}

static GoString *newFloatString(double src) {
  char *s = (char *)malloc(32);
  memset(s, 0, 32);
  snprintf(s, 32, "%lf", src);
  return newStringWithLength(s, strlen(s));
}

static void to_string_ptr(void *arg) {
  char **strptr = (char **)arg;
  *(void **)arg = newString(*strptr);
}

static void to_string_ptr_with_length(void *arg, int length) {
  char **strptr = (char **)arg;
  *(void **)arg = newStringWithLength(*strptr, length);
}

{{- range .ExportCallbackFunctions }}
{{- $name := .Name }}
{{ .Return }} wasm_bridge_{{ $name }}({{- range .Args -}}{{ .Value.GoType }} arg{{- .Index -}}{{- if not .IsLastArg -}}, {{ end -}}{{- end -}});

{{ .Return }} {{ $name }}({{- range .Args -}}{{- .Value.CType }} _arg{{- .Index -}}{{- if not .IsLastArg -}}, {{ end -}}{{- end -}}) {
  {{- range .Args }}
  {{- template "toGoValue" .Value }}
  {{- end }}
  return wasm_bridge_{{ $name }}(
    {{- range .Args }}
    arg{{- .Index }}{{- if not .IsLastArg -}},{{- end -}}
    {{- end }}
  );
}
{{ end }}

{{- range .ExportEnums }}
{{ range .Values }}
int wasm_bridge_get_{{ .Name }}() {
  return {{ .Name }};
}
{{ end }}
{{- end }}

{{ range .ExportMessages }}
{{- if .HasConstructor }}
void *wasm_bridge_new_{{ .Name }}() {
  void *ret = malloc(sizeof({{ .Type }}));
  memset(ret, 0, sizeof({{ .Type }}));
  return ret;
}
{{ end }}
{{- range .Fields }}
{{- if .Value.IsFunction }}
void wasm_bridge_set_{{ .Name }}({{ .ReceiverType }} *recv) {
  {{ .Value.Src }} = {{ .Value.FuncName }};
}
{{- else }}
void wasm_bridge_get_{{ .Name }}({{ .ReceiverType }} *recv, {{ .Value.GoType }}* ret) {
  {{- template "toGoValue" .Value }}
  *ret = {{ .Value.Dst }};
}

void wasm_bridge_set_{{ .Name }}({{ .ReceiverType }} *recv, {{ .Value.WasmType }} v) {
  {{- template "toCValue" (map "Value" .Value "Dst" .Value.Src "Src" "v" ) }}
}
{{- end }}
{{ end }}
{{- end }}

{{ range .ExportFunctions }}
void wasm_bridge_{{ .Name }}({{- range .Args -}}{{- .Value.WasmType }} _arg{{- .Index -}}{{- if not .IsLastArg -}}, {{ end -}}{{- end -}}) {
  {{- range .FuncArgs }}
  {{- if not .Value.IsFunction }}
  {{ .Value.CType }} {{ .Dst }};
  {{- template "toCValue" (map "Value" .Value "Dst" .Dst "Src" .Src ) }}
  {{- end }}
  {{- end }}

  {{- if .Return }}
  {{ .Return.Value.CType }} ret = {{ .Function }}(
    {{- range .FuncArgs }}
    {{- if .Value.IsFunction }}
    {{ .Value.FuncName }}{{- if not .IsLastArg -}},{{ end -}}
    {{- else }}
    arg{{ .Index }}{{- if not .IsLastArg -}},{{ end -}}
    {{- end }}
    {{- end }}
  );
  {{- $funcArgs := .FuncArgs }}
  {{- range $funcArgs }}
  {{- if .Value.IsPtrValue }}
  {{- if .Value.IsStringKind }}
  {{- if .Value.ArgStringLength }}

  {{- $index := .Value.ArgStringLength  }}
  {{- $arg := index $funcArgs $index }}
  {{- if $arg.Value.IsPtrValue }}
  to_string_ptr_with_length(_arg{{ .Index }}, *(int *)_arg{{ $index }});
  {{- else }}
  to_string_ptr_with_length(_arg{{ .Index }}, _arg{{ $index }});
  {{- end }}
  {{- else }}
  to_string_ptr(_arg{{ .Index }});
  {{- end }}

  {{- end }}
  {{- end }}
  {{- end }}
  {{- template "toGoValue" .Return.Value }}
  *_arg{{ .Return.Index }} = {{ .Return.Value.Dst }};
  {{- else }}
  {{ .Function }}(
    {{- range .FuncArgs }}
    {{- if .Value.IsFunction }}
    {{ .Value.FuncName }}{{- if not .IsLastArg -}},{{- end -}}
    {{- else }}
    arg{{ .Index }}{{- if not .IsLastArg -}},{{ end -}}
    {{- end }}
    {{- end }}
  );
  {{- end }}
}
{{ end }}

#ifdef __cplusplus
}
#endif /* __cplusplus */


{{- define "toCValue" -}}
  {{- if .Value.IsSlice }}
  {{- if not .Value.FixedArrayNum }}
  {{ .Dst }} = ({{ .Value.CType }})malloc(sizeof({{ .Value.Elem.CType }}) * {{ .Src }}->len);
  {{- end }}
  for (int i = 0; i < {{ .Src }}->len; i++) {
    void *elem = ((void **){{ .Src }}->data)[i * 2];
    {{- if .Value.IsPtrValue }}
    {{ .Dst }}[i] = ({{ .Value.Elem.CType }})elem;
    {{- else }}
    memcpy(&{{ .Dst }}[i], elem, sizeof({{ .Value.Elem.CType }}));
    {{- end }}
  }
  {{- else }}
  {{ .Dst }} = {{ .Value.Converter }}{{ .Src }};
  {{- end }}
{{- end -}}

{{- define "toGoValue" -}}
  {{- if .IsSlice }}
  {{- template "toSlice" . }}
  {{- else if .IsString }}
  GoString *{{ .Dst }} = newString({{ .Src }});
  {{- else if and .IsPtrValue .IsStringKind }}
  to_string_ptr({{ .Src }});
  {{- else if .IsFloat }}
  GoString *{{ .Dst }} = newFloatString({{ .Src }});
  {{- else if .IsStruct }}
  void *{{ .Dst }} = malloc(sizeof({{ .Src }}));
  memcpy({{ .Dst }}, &{{ .Src }}, sizeof({{ .Src }}));
  {{- else }}
  {{ .CType }} {{ .Dst }} = {{ .Converter }}{{ .Src }};
  {{- end }}
{{- end -}}

{{- define "toSlice" -}}
  GoSlice *{{ .Dst }} = (GoSlice *)malloc(sizeof(GoSlice));
  {{- if .FixedArrayNum }}
  int {{ .Dst }}_length = {{ .FixedArrayNum }};
  {{- else if .ArrayNumArgIndex }}
  int {{ .Dst }}_length = _arg{{ .ArrayNumArgIndex }};
  {{- else if or .IsStringKind .Type.Pointer }}
  int {{ .Dst }}_length = 0;
  for (int i = 0; {{ .Src }}[i] != NULL; i++) {
    {{ .Dst }}_length++;
  }
  {{- else }}
  int {{ .Dst }}_length = 0;
  {{- end }}
  {{ .Dst }}->len = {{ .Dst }}_length;
  void **{{ .Dst }}_data = (void **)malloc(8 * {{ .Dst }}_length);
  {{ .Dst }}->data = {{ .Dst }}_data;
  for (int i = 0; i < {{ .Dst }}_length; i++) {
    {{- template "toGoValue" .Elem }}
    *{{ .Dst }}_data = (void *){{ .IntPtr }}v;
    {{ .Dst }}_data += 2; // move data header address by 2 word (8 bytes).
  }

{{- end -}}
