// Code generated by protoc-gen-nori. DO NOT EDIT!

package wasm

import (
	"context"
	_ "embed"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"unsafe"
	"reflect"
	"strconv"

	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
	"github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1"
)

var _ unsafe.Pointer

//go:embed {{ .WasmName }}.wasm
var wasmFile []byte

type WasmModule struct {
	mod api.Module
	fs  *WasmFileSystem
	lookupFuncMap *LookupFuncMap
	callbackFuncMap *CallbackFuncMap
}

type WasmFileSystem struct {
	subFS fs.FS
}

func (fs *WasmFileSystem) Open(name string) (fs.File, error) {
	if fs.subFS != nil {
		return fs.subFS.Open(name)
	}
	return os.Open(name)
}

type LookupFuncMap struct {
	{{- range .ExportCallbackFunctions }}
	{{ .Name }} func({{- range .Args }}{{ .Value.GoType }},{{- end }}) (uint64, error)
	{{- end }}
}

type CallbackFuncMap struct {
	{{- range .ExportCallbackFunctions }}
	{{- if .Return }}
	{{ .Name }} map[uint64]func(context.Context, {{- range .Args }}{{ .Value.GoType }},{{- end }}) ({{ .Return.Value.GoType }}, error)
	{{- else }}
	{{ .Name }} map[uint64]func(context.Context, {{- range .Args }}{{ .Value.GoType }},{{- end }}) error
	{{- end }}
	{{- end }}
}

{{- range .ExportCallbackFunctions }}
func Register_{{ .Name }}(fn func({{- range .Args }}{{ .Value.GoType }},{{- end }}) (uint64, error)) {
	mod.lookupFuncMap.{{ .Name }} = fn
}
{{- end }}

var mod *WasmModule

type CallbackFunc[T any] struct {
	cb     T
	funcID uint64
}

func CreateCallbackFunc[T any](cb T, funcID uint64) *CallbackFunc[T] {
	return &CallbackFunc[T]{
		cb: cb,
		funcID: funcID,
	}
}

func init() {
	ctx := context.Background()
	cfg := wazero.NewRuntimeConfig()
	if cache := getCompilationCache(); cache != nil {
		cfg = cfg.WithCompilationCache(cache)
	}

	r := wazero.NewRuntimeWithConfig(ctx, cfg)

	env := r.NewHostModuleBuilder("env")
	{{- range .ExportCallbackFunctions }}
	env = env.NewFunctionBuilder().WithGoModuleFunction(
		api.GoModuleFunc(func(ctx context.Context, _ api.Module, stack []uint64) {
			{{- range .Args }}
			arg{{ .Index }}, err := func() ({{ .Value.GoType }}, error) {
				var zero {{ .Value.GoType }}
				_ = zero
				{{- if .Value.IsPtrValue }}
				ret := new({{ .Value.Elem.GoType }})
				{{- end }}
				{{- template "ToGoValue" . }}
				{{- if .Value.IsPtrValue }}
				return ret, nil
				{{- else }}
				return {{ .Dst }}, nil
				{{- end }}
			}()
			if err != nil {
				panic(err)
			}
			{{- end }}

			funcID, err := mod.lookupFuncMap.{{ .Name }}({{- range .Args}}arg{{ .Index }},{{- end }})
			if err != nil {
				panic(err)
			}
			if fn, exists := mod.callbackFuncMap.{{ .Name }}[funcID]; exists {
				{{- if .Return }}
				// TODO: must back returned value to wasm side.
				if _, err := fn(ctx, {{- range .Args}}arg{{ .Index }},{{- end }}); err != nil {
					panic(err)
				}
				{{- else }}
				if err := fn(ctx, {{- range .Args}}arg{{ .Index }},{{- end }}); err != nil {
					panic(err)
				}
				{{- end }}
			}
		}),
		[]api.ValueType{ {{- range .Args }}api.ValueTypeI{{- if .Value.Is64Bit -}}64{{- else -}}32{{- end -}},{{- end }} },
		{{- if .Return }}
		[]api.ValueType{api.ValueTypeI{{- if .Return.Value.Is64Bit -}}64{{- else -}}32{{- end -}} },
		{{- else }}
		[]api.ValueType{},
		{{- end }}
	).Export("wasm_bridge_{{ .Name }}")
	{{- end }}
	if _, err := env.Instantiate(ctx); err != nil {
		panic(err)
	}
	wasi_snapshot_preview1.MustInstantiate(ctx, r)

	compiled, err := r.CompileModule(ctx, wasmFile)
	if err != nil {
		panic(err)
	}
	fs := &WasmFileSystem{}
	m, err := r.InstantiateModule(
		ctx,
		compiled,
		wazero.NewModuleConfig().
			WithFSConfig(wazero.NewFSConfig().WithFSMount(fs, "/")).
			WithStdout(os.Stdout).
			WithName("wasi"),
	)
	if err != nil {
		panic(err)
	}
	mod = &WasmModule{
		mod: m,
		fs: fs,
		lookupFuncMap: &LookupFuncMap{},
		callbackFuncMap: &CallbackFuncMap{
			{{- range .ExportCallbackFunctions }}
			{{- if .Return }}
			{{ .Name }}: make(map[uint64]func(context.Context, {{- range .Args }}{{ .Value.GoType }},{{- end }}) ({{ .Return.Value.GoType }}, error)),
			{{- else }}
			{{ .Name }}: make(map[uint64]func(context.Context, {{- range .Args }}{{ .Value.GoType }},{{- end }}) error),
			{{- end }}
			{{- end }}
		},
	}
	{{- range .ExportEnums }}
	{{- $enumName := .Name }}
	// bind {{ $enumName }} values.
	{{- range .EnumValues }}
	{{ .GoName }} = {{ $enumName }}(mod.getEnumValue(ctx, "{{ .WasmName }}"))
	{{- end }}
	{{- end }}
}

func (m *WasmModule) getEnumValue(ctx context.Context, value string) int {
	ret, err := mod.ExportedFunction("wasm_bridge_get_" + value).Call(ctx)
	if err != nil {
		panic(err)
	}
	return mod.toInt(ret[0])
}

func WasmPtr(v wasmStruct) uint64 {
	return v.getPtr()
}

func getCompilationCache() wazero.CompilationCache {
	tmpDir := os.TempDir()
	if tmpDir == "" {
		return nil
	}
	cacheDir := filepath.Join(tmpDir, "go-graphviz")
	if _, err := os.Stat(cacheDir); err != nil {
		if err := os.Mkdir(cacheDir, 0o755); err != nil {
			return nil
		}
	}
	cache, err := wazero.NewCompilationCacheWithDir(cacheDir)
	if err != nil {
		return nil
	}
	return cache
}

func (m *WasmModule) ExportedFunction(name string) api.Function {
	return m.mod.ExportedFunction(name)
}

func (m *WasmModule) malloc(ctx context.Context, size uint64) (uint64, error) {
	ret, err := m.ExportedFunction("malloc").Call(ctx, size)
	if err != nil {
		return 0, err
	}
	return ret[0], nil
}

func (m *WasmModule) free(ctx context.Context, p uint64) error {
	if _, err := m.ExportedFunction("free").Call(ctx, p); err != nil {
		return err
	}
	return nil
}

func (m *WasmModule) newObject(ctx context.Context, name string) (uint64, error) {
	ret, err := mod.ExportedFunction("wasm_bridge_new_" + name).Call(ctx)
	if err != nil {
		return 0, err
	}
	return ret[0], nil
}

func (m *WasmModule) setField(ctx context.Context, name string, recv, arg uint64) error {
	if _, err := mod.ExportedFunction("wasm_bridge_set_" + name).Call(ctx, recv, arg); err != nil {
		return err
	}
	return nil
}

func (m *WasmModule) setFieldFunction(ctx context.Context, name string, recv uint64) error {
	if _, err := mod.ExportedFunction("wasm_bridge_set_" + name).Call(ctx, recv); err != nil {
		return err
	}
	return nil
}

func (m *WasmModule) getField(ctx context.Context, name string, recv uint64) (ret uint64, e error) {
	retPtr, err := m.NewPtr(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		e = m.free(ctx, retPtr)
	}()

	if _, err := m.ExportedFunction("wasm_bridge_get_" + name).Call(ctx, recv, retPtr); err != nil {
		return 0, err
	}
	p, err := m.readU32(retPtr)
	if err != nil {
		return 0, err
	}
	return p, nil
}

func (m *WasmModule) call(ctx context.Context, name string, args ...uint64) error {
	if _, err := mod.ExportedFunction("wasm_bridge_" + name).Call(ctx, args...); err != nil {
		return err
	}
	return nil
}

func (m *WasmModule) callWithRet(ctx context.Context, name string, args ...uint64) (r uint64, e error) {
	retPtr, err := m.NewPtr(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		e = m.free(ctx, retPtr)
	}()

	if err := m.call(ctx, name, append(append([]uint64{}, args...), retPtr)...); err != nil {
		return 0, err
	}
	p, err := m.readU32(retPtr)
	if err != nil {
		return 0, err
	}
	return p, nil
}

func (m *WasmModule) read(addr, length uint64) ([]byte, error) {
	bytes, ok := m.mod.Memory().Read(uint32(addr), uint32(length))
	if !ok {
		return nil, fmt.Errorf(
			`failed to read wasm memory: (ptr, size) = (%d, %d) and memory size is %d`,
			addr, length, m.mod.Memory().Size(),
		)
	}
	return bytes, nil
}

func (m *WasmModule) readU32(addr uint64) (uint64, error) {
	p, ok := m.mod.Memory().ReadUint32Le(uint32(addr))
	if !ok {
		return 0, fmt.Errorf(
			`failed to read wasm memory: (ptr, size) = (%d, 4) and memory size is %d`,
			addr, m.mod.Memory().Size(),
		)
	}
	return uint64(p), nil
}

func (m *WasmModule) write(p uint64, b []byte) error {
	if !m.mod.Memory().Write(uint32(p), b) {
		return fmt.Errorf(
			`failed to write wasm memory: (ptr, size) = (%d, %d) and memory size is %d`,
			p, len(b), m.mod.Memory().Size(),
		)
	}
	return nil
}

func (m *WasmModule) writeU32(p uint64, v uint32) error {
	if !m.mod.Memory().WriteUint32Le(uint32(p), v) {
		return fmt.Errorf(
			`failed to write wasm memory: ptr = %d and memory size is %d`,
			p, m.mod.Memory().Size(),
		)
	}
	return nil
}

func (m *WasmModule) writeU64(p uint64, v uint64) error {
	if !m.mod.Memory().WriteUint64Le(uint32(p), v) {
		return fmt.Errorf(
			`failed to write wasm memory: ptr = %d and memory size is %d`,
			p, m.mod.Memory().Size(),
		)
	}
	return nil
}

func (m *WasmModule) writeF64(p uint64, v float64) error {
	if !m.mod.Memory().WriteFloat64Le(uint32(p), v) {
		return fmt.Errorf(
			`failed to write wasm memory: ptr = %d and memory size is %d`,
			p, m.mod.Memory().Size(),
		)
	}
	return nil
}

func (m *WasmModule) NewPtr(ctx context.Context) (uint64, error) {
	return m.malloc(ctx, 4)
}

func (m *WasmModule) toSlice(ctx context.Context, p uint64) ([]uint64, error) {
	length, err := m.readU32(p)
	if err != nil {
		return nil, err
	}
	data, err := m.readU32(p+4)
	if err != nil {
		return nil, err
	}
	var ret []uint64
	for i := uint64(0); i < length; i++ {
		p, err := m.readU32(data+8*i)
		if err != nil {
			return nil, err
		}
		ret = append(ret, p)
	}
	return ret, nil
}

func (m *WasmModule) toBool(p uint64) bool {
	if p == 1 {
		return true
	}
	return false
}

func (m *WasmModule) toBoolSlice(v []uint64) []bool {
	var ret []bool
	for _, vv := range v {
		ret = append(ret, m.toBool(vv))
	}
	return ret
}

func (m *WasmModule) toFloat32(ctx context.Context, p uint64) (float32, error) {
	v, err := m.toString(ctx, p)
	if err != nil {
		return 0, err
	}
	f64, err := strconv.ParseFloat(v, 64)
	if err != nil {
		return 0, err
	}
	return float32(f64), nil
}

func (m *WasmModule) toFloat32Slice(ctx context.Context, v []uint64) ([]float32, error) {
	var ret []float32
	for _, vv := range v {
		f, err := m.toFloat32(ctx, vv)
		if err != nil {
			return nil, err
		}
		ret = append(ret, f)
	}
	return ret, nil
}

func (m *WasmModule) toFloat64(ctx context.Context, p uint64) (float64, error) {
	v, err := m.toString(ctx, p)
	if err != nil {
		return 0, err
	}
	f64, err := strconv.ParseFloat(v, 64)
	if err != nil {
		return 0, err
	}
	return f64, nil
}

func (m *WasmModule) toFloat64Slice(ctx context.Context, v []uint64) ([]float64, error) {
	var ret []float64
	for _, vv := range v {
		f, err := m.toFloat64(ctx, vv)
		if err != nil {
			return nil, err
		}
		ret = append(ret, f)
	}
	return ret, nil
}

func (m *WasmModule) toInt(p uint64) int {
	return int(p)
}

func (m *WasmModule) toIntSlice(v []uint64) []int {
	var ret []int
	for _, vv := range v {
		ret = append(ret, m.toInt(vv))
	}
	return ret
}

func (m *WasmModule) toInt32(v uint64) int32 {
	return int32(v)
}

func (m *WasmModule) toInt32Slice(v []uint64) []int32 {
	var ret []int32
	for _, vv := range v {
		ret = append(ret, m.toInt32(vv))
	}
	return ret
}

func (m *WasmModule) toInt64(v uint64) int64 {
	return int64(v)
}

func (m *WasmModule) toInt64Slice(v []uint64) []int64 {
	var ret []int64
	for _, vv := range v {
		ret = append(ret, m.toInt64(vv))
	}
	return ret
}

func (m *WasmModule) toUint(p uint64) uint {
	return uint(p)
}

func (m *WasmModule) toUintSlice(v []uint64) []uint {
	var ret []uint
	for _, vv := range v {
		ret = append(ret, m.toUint(vv))
	}
	return ret
}

func (m *WasmModule) toUint32(v uint64) uint32 {
	return uint32(v)
}

func (m *WasmModule) toUint32Slice(v []uint64) []uint32 {
	var ret []uint32
	for _, vv := range v {
		ret = append(ret, m.toUint32(vv))
	}
	return ret
}

func (m *WasmModule) toUint64(v uint64) uint64 {
	return v
}

func (m *WasmModule) toUint64Slice(v []uint64) []uint64 {
	return v
}

func (m *WasmModule) toAny(v uint64) any {
	return v
}

func (m *WasmModule) toString(ctx context.Context, p uint64) (string, error) {
	if p == 0 {
		return "", nil
	}
	dataAddr, err := m.readU32(p)
	if err != nil {
		return "", err
	}
	length, err := m.readU32(p+4)
	if err != nil {
		return "", err
	}
	if length == 0 {
		return "", nil
	}
	bytes, err := m.read(dataAddr, length)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

func (m *WasmModule) toStringSlice(ctx context.Context, v []uint64) ([]string, error) {
	var ret []string
	for _, vv := range v {
		s, err := m.toString(ctx, vv)
		if err != nil {
			return nil, err
		}
		ret = append(ret, s)
	}
	return ret, nil
}

func (m *WasmModule) toObjectWasmValue(_ context.Context, v wasmStruct) (uint64, error) {
	return v.getPtr(), nil
}

func (m *WasmModule) toAnyWasmValue(_ context.Context, v any) (uint64, error) {
	switch vv := v.(type) {
	case wasmStruct:
		return vv.getPtr(), nil
	}
	return 0, nil
}

func (m *WasmModule) toPtrWasmValue(ctx context.Context, _ any) (uint64, error) {
	return m.NewPtr(ctx)
}


type wasmStruct interface {
	getPtr() uint64
}

type numberType interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}


func (m *WasmModule) toIntWasmValue(_ context.Context, v any) (uint64, error) {
	switch vv := v.(type) {
	case int:
		return uint64(vv), nil
	case int8:
		return uint64(vv), nil
	case int16:
		return uint64(vv), nil
	case int32:
		return uint64(vv), nil
	case int64:
		return uint64(vv), nil
	}
	return uint64(reflect.ValueOf(v).Int()), nil
}

func (m *WasmModule) toInt32WasmValue(_ context.Context, v int32) (uint64, error) {
	return uint64(v), nil
}

func (m *WasmModule) toInt64WasmValue(_ context.Context, v int64) (uint64, error) {
	return uint64(v), nil
}

func (m *WasmModule) toUintWasmValue(_ context.Context, v any) (uint64, error) {
	switch vv := v.(type) {
	case uint:
		return uint64(vv), nil
	case uint8:
		return uint64(vv), nil
	case uint16:
		return uint64(vv), nil
	case uint32:
		return uint64(vv), nil
	case uint64:
		return vv, nil
	}
	return 0, nil
}

func (m *WasmModule) toUint32WasmValue(_ context.Context, v uint32) (uint64, error) {
	return uint64(v), nil
}

func (m *WasmModule) toUint64WasmValue(_ context.Context, v uint64) (uint64, error) {
	return v, nil
}

func (m *WasmModule) toBoolWasmValue(_ context.Context, v bool) (uint64, error) {
	if v {
		return 1, nil
	}
	return 0, nil
}

func (m *WasmModule) toFuncWasmValue(_ context.Context, _ any) (uint64, error) {
	return 0, nil
}

func (m *WasmModule) toFloatWasmValue(_ context.Context, v float32) (uint64, error) {
	return api.EncodeF32(v), nil
}

func (m *WasmModule) toDoubleWasmValue(_ context.Context, v float64) (uint64, error) {
	return api.EncodeF64(v), nil
}

func (m *WasmModule) toIntArrayWasmValue(ctx context.Context, v []int) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, uint64(vv)); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toInt32ArrayWasmValue(ctx context.Context, v []int32) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, uint64(vv)); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toInt64ArrayWasmValue(ctx context.Context, v []int64) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, uint64(vv)); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toUintArrayWasmValue(ctx context.Context, v []uint) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, uint64(vv)); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toUint32ArrayWasmValue(ctx context.Context, v []uint32) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, uint64(vv)); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toUint64ArrayWasmValue(ctx context.Context, v []uint64) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeU64(ptr, vv); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toDoubleArrayWasmValue(ctx context.Context, v []float64) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		if err := m.writeF64(ptr, vv); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toFloatStringWasmValue(ctx context.Context, v float32) (uint64, error) {
	return m.toStringWasmValue(ctx, fmt.Sprint(v))
}

func (m *WasmModule) toDoubleStringWasmValue(ctx context.Context, v float64) (uint64, error) {
	return m.toStringWasmValue(ctx, fmt.Sprint(v))
}

func (m *WasmModule) toFloatStringArrayWasmValue(ctx context.Context, v []float32) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		f, err := m.toFloatStringWasmValue(ctx, vv)
		if err != nil {
			return 0, err
		}
		if err := m.writeU64(ptr, f); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toDoubleStringArrayWasmValue(ctx context.Context, v []float64) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(8*len(v)))
	if err != nil {
		return 0, err
	}
	ptr := ret
	for _, vv := range v {
		f, err := m.toDoubleStringWasmValue(ctx, vv)
		if err != nil {
			return 0, err
		}
		if err := m.writeU64(ptr, f); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

func (m *WasmModule) toStringWasmValue(ctx context.Context, s string) (uint64, error) {
	ret, err := m.malloc(ctx, uint64(len(s))+1)
	if err != nil {
		return 0, err
	}
	if err := m.write(ret, append([]byte(s), 0)); err != nil {
		return 0, err
	}
	return ret, nil
}

func (m *WasmModule) toStringArrayWasmValue(ctx context.Context, v []string) (uint64, error) {
	return 0, nil
}

func (m *WasmModule) toObjectArrayWasmValue(ctx context.Context, v any) (uint64, error) {
	ret, err := m.malloc(ctx, 4+4) // GoSlice
	if err != nil {
		return 0, err
	}
	rv := reflect.ValueOf(v)
	if err := m.writeU32(ret, uint32(rv.Len())); err != nil {
		return 0, err
	}
	data, err := m.malloc(ctx, uint64(8*rv.Len()))
	if err != nil {
		return 0, err
	}
	if err := m.writeU32(ret+4, uint32(data)); err != nil {
		return 0, err
	}
	ptr := data
	for i := 0; i < rv.Len(); i++ {
		vv := rv.Index(i).Interface().(wasmStruct)
		if err := m.writeU32(ptr, uint32(vv.getPtr())); err != nil {
			return 0, err
		}
		ptr += 8
	}
	return ret, nil
}

{{- range .ExportMessages }}
{{- $msgName := .Name }}

type {{ $msgName }} struct {
	ptr uint64
}
{{- if .HasConstructor }}
func New{{ $msgName }}(ctx context.Context) (*{{ $msgName }}, error) {
	o, err := mod.newObject(ctx, "{{ $msgName }}")
	if err != nil {
		return nil, err
	}
	return new{{ $msgName }}(o), nil
}
{{ end }}
func new{{ $msgName }}(ptr uint64) *{{ $msgName }} {
	if ptr == 0 {
		return nil
	}
	return &{{ $msgName }}{ptr: ptr}
}

func (v *{{ $msgName }}) getPtr() uint64 {
	if v == nil {
		return 0
	}
	return v.ptr
}

func new{{ $msgName }}Slice(v []uint64) []*{{ $msgName }} {
	ret := make([]*{{ $msgName }}, 0, len(v))
	for _, vv := range v {
		ret = append(ret, new{{ $msgName }}(vv))
	}
	return ret
}

{{- range .Fields }}

{{- if .Value.IsFunction }}
func (v *{{ $msgName }}) Set{{ .GoName }}(ctx context.Context, arg {{ .Value.GoInterfaceType }}) error {
	if mod.lookupFuncMap.{{ .Value.FuncName }} == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_{{ .Value.FuncName }} before")
	}
	mod.callbackFuncMap.{{ .Value.FuncName }}[arg.funcID] = arg.cb
	return mod.setFieldFunction(ctx, "{{ .WasmName }}", v.getPtr())
}
{{- else }}
func (v *{{ $msgName }}) Set{{ .GoName }}(_arg {{ .Value.GoType }}) error {
	ctx := context.Background()
	arg, err := {{ .Value.WasmTypeConverter }}(ctx, _arg)
	if err != nil {
		return err
	}
	return mod.setField(ctx, "{{ .WasmName }}", v.getPtr(), arg)
}

func (v *{{ $msgName }}) Get{{ .GoName }}() {{ .Value.GoType }} {
	ret, err := v.get{{ .GoName }}(context.Background())
	if err != nil {
		panic(err)
	}
	return ret
}

func (v *{{ $msgName }}) get{{ .GoName }}(ctx context.Context) ({{ .Value.GoType }}, error) {
	var zero {{ .Value.GoType }}
	p, err := mod.getField(ctx, "{{ .WasmName }}", v.getPtr())
	if err != nil {
		return zero, err
	}
	{{- template "ToGoValue" . }}
	return {{ .Dst }}, nil
}
{{- end }}
{{ end }}
{{- end }}

{{ range .ExportEnums }}
{{ $enumName := .Name }}
type {{ $enumName }} int
var (
	{{- range $index, $value := .EnumValues }}
	{{ $value.GoName }} {{ $enumName }} = {{ $index }}
	{{- end }}
)

func (v {{ $enumName }}) String() string {
	switch v {
	{{- range .EnumValues }}
	case {{ .GoName }}:
		return "{{ .GoName }}"
	{{- end }}
	}
	return ""
}
{{ end }}

{{ range .ExportMethods }}
{{- if .Return }}
func (v *{{ .Receiver }}) {{ .GoName }}(ctx context.Context, {{- range .Args -}}_arg{{- .Index }} {{ .Value.GoInterfaceType }}{{- if not .IsLastArg -}}, {{ end -}}{{- end -}}) ({{ .Return.Value.GoType }}, error) {
	var zero {{ .Return.Value.GoType }}
	{{- range .Args }}
	{{- if .Value.IsFunction }}
	if mod.lookupFuncMap.{{ .Value.FuncName }} == nil {
		return zero, fmt.Errorf("cannot find lookup function. you must call Register_{{ .Value.FuncName }} before")
	}
	mod.callbackFuncMap.{{ .Value.FuncName }}[_arg{{ .Index }}.funcID] = _arg{{ .Index }}.cb
	{{- end }}
	arg{{- .Index -}}, err := {{ .Value.WasmTypeConverter }}(ctx, _arg{{- .Index -}})
	if err != nil {
		return zero, err
	}
	{{- end }}
	p, err := mod.callWithRet(ctx, "{{ .WasmName }}", v.getPtr(), {{- range .Args }}arg{{- .Index -}},{{- end }})
	if err != nil {
		return zero, err
	}
	{{- range .Args }}
	{{- if .Value.IsPtrValue }}
	{
		p, err := mod.readU32(arg{{ .Index }})
		if err != nil {
			return zero, err
		}
		{{- template "ToGoValue" . }}
	}
	{{- end }}
	{{- end }}
	{{- template "ToGoValue" .Return }}
	return {{ .Return.Dst }}, nil
}
{{- else }}
func (v *{{ .Receiver }}) {{ .GoName }}(ctx context.Context, {{- range .Args -}}_arg{{- .Index }} {{ .Value.GoInterfaceType }}{{- if not .IsLastArg -}}, {{ end -}}{{- end -}}) error {
	{{- range .Args }}
	{{- if .Value.IsFunction }}
	if mod.lookupFuncMap.{{ .Value.FuncName }} == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_{{ .Value.FuncName }} before")
	}
	mod.callbackFuncMap.{{ .Value.FuncName }}[_arg{{ .Index }}.funcID] = _arg{{ .Index }}.cb
	{{- end }}
	arg{{- .Index -}}, err := {{ .Value.WasmTypeConverter }}(ctx, _arg{{- .Index -}})
	if err != nil {
		return err
	}
	{{- end }}
	if err := mod.call(ctx, "{{ .WasmName }}", v.getPtr(), {{- range .Args }}arg{{- .Index -}},{{- end }}); err != nil {
		return err
	}
	return nil
}
{{- end }}
{{ end }}


{{ range .ExportFunctions }}
{{- if .Return }}
func {{ .GoName }}(ctx context.Context, {{- range .Args -}}_arg{{- .Index }} {{ .Value.GoInterfaceType }}{{- if not .IsLastArg -}}, {{ end -}}{{- end -}}) ({{ .Return.Value.GoType }}, error) {
	var zero {{ .Return.Value.GoType }}
	{{- range .Args }}
	{{- if .Value.IsFunction }}
	if mod.lookupFuncMap.{{ .Value.FuncName }} == nil {
		return zero, fmt.Errorf("cannot find lookup function. you must call Register_{{ .Value.FuncName }} before")
	}
	mod.callbackFuncMap.{{ .Value.FuncName }}[_arg{{ .Index }}.funcID] = _arg{{ .Index }}.cb
	{{- end }}
	arg{{- .Index -}}, err := {{ .Value.WasmTypeConverter }}(ctx, _arg{{- .Index -}})
	if err != nil {
		return zero, err
	}
	{{- end }}
	p, err := mod.callWithRet(ctx, "{{ .WasmName }}", {{- range .Args }}arg{{- .Index -}},{{- end }})
	if err != nil {
		return zero, err
	}
	{{- range .Args }}
	{{- if .Value.IsPtrValue }}
	{
		p, err := mod.readU32(arg{{ .Index }})
		if err != nil {
			return zero, err
		}
		{{- template "ToGoValue" . }}
	}
	{{- end }}
	{{- end }}
	{{- template "ToGoValue" .Return }}
	return {{ .Return.Dst }}, nil
}
{{- else }}
func {{ .GoName }}(ctx context.Context, {{- range .Args -}}_arg{{- .Index }} {{ .Value.GoInterfaceType }}{{- if not .IsLastArg -}}, {{ end -}}{{- end -}}) error {
	{{- range .Args }}
	{{- if .Value.IsFunction }}
	if mod.lookupFuncMap.{{ .Value.FuncName }} == nil {
		return fmt.Errorf("cannot find lookup function. you must call Register_{{ .Value.FuncName }} before")
	}
	mod.callbackFuncMap.{{ .Value.FuncName }}[_arg{{ .Index }}.funcID] = _arg{{ .Index }}.cb
	{{- end }}
	arg{{- .Index -}}, err := {{ .Value.WasmTypeConverter }}(ctx, _arg{{- .Index -}})
	if err != nil {
		return err
	}
	{{- end }}
	if err := mod.call(ctx, "{{ .WasmName }}", {{- range .Args }}arg{{- .Index -}},{{- end }}); err != nil {
		return err
	}
	{{- range .Args }}
	{{- if .Value.IsPtrValue }}
	{
		p, err := mod.readU32(arg{{ .Index }})
		if err != nil {
			return err
		}
		if _, err := func() (any, error) {
			var zero any
			{{- template "ToGoValue" . }}
			return {{ .Dst }}, nil
		}(); err != nil {
			return err
		}
	}
	{{- end }}
	{{- end }}
	return nil
}
{{- end }}
{{ end }}

{{- define "ToGoValue" }}
{{- if .Value.IsPtrValue }}
{{- template "toGoValueWithSlice" (map "Src" .Src "Dst" "value" "Value" .Value) }}
*{{ .Dst }} = value
{{- else }}
{{- template "toGoValueWithSlice" . }}
{{- end }}

{{- end }}

{{- define "toGoValueWithSlice" }}

{{- if .Value.IsSlice }}
slice, err := mod.toSlice(ctx, {{ .Src }})
if err != nil {
	return zero, err
}
{{- template "toGoValue" (map "Src" "slice" "Dst" .Dst "Value" .Value) }}
{{- else }}
{{- template "toGoValue" . }}
{{- end }}

{{- end }}

{{- define "toGoValue" }}

{{- if or .Value.IsStringKind .Value.IsFloatKind }}
{{ .Dst }}, err := {{ .Value.GoTypeConverter }}(ctx, {{ .Src }})
if err != nil {
	return zero, err
}
{{- else }}
{{ .Dst }} := {{ .Value.GoTypeConverter }}({{ .Src }})
{{- end }}

{{- end }}
